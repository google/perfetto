# Trace Summary

The Perfetto trace processor allows for the computation of "trace summaries," which are structured representations of important properties extracted from a trace. These summaries are defined by a specification and result in a corresponding output proto, making them consumable by various tools and systems.

## Overview

The trace summary system revolves around two main protobuf messages located in `protos/perfetto/trace_summary/file.proto`:

*   **[`TraceSummarySpec`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/perfetto/protos/perfetto/trace_summary/file.proto;l=35?q=tracesummaryspec&sq=)**: Defines *what* and *how* to compute from the trace.
*   **[`TraceSummary`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/perfetto/protos/perfetto/trace_summary/file.proto;l=53?q=tracesummaryspec)**: Contains the *results* of the computation.

## Summary Specification

The [`TraceSummarySpec`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/perfetto/protos/perfetto/trace_summary/file.proto;l=35?q=tracesummaryspec) message is the top-level proto used to configure how a trace should be summarized. It acts as a container for one or more metric specifications and shared queries.

Key components:

*   **`metric_spec` (repeated `TraceMetricV2Spec`)**: Defines individual metrics to be computed. See Defining Metrics (`TraceMetricV2Spec`) for details.
*   **`query` (repeated `PerfettoSqlStructuredQuery`)**: Specifies structured queries. These queries serve two purposes:
    *   **Shared Queries for Metrics**: They can be referenced by the `inner_query_id` field within a `metric_spec.query`. This allows a single, complex query definition to be reused across multiple metrics.
    *   **Trace-Wide Metadata**: A `PerfettoSqlStructuredQuery` from this list can be designated (e.g., via `metadata_query_id` in the Python API or `--summary-metadata-query` in the shell) to compute trace-wide metadata. Such a designated query is expected to return rows with two columns, typically named "key" and "value" (both strings or convertible to strings). Each row from this query's result will populate a `Metadata` entry in the `TraceSummary.metadata` list. Queries in this list not referenced by a metric or designated for metadata are not automatically executed.

## Summary Output

The `TraceSummary` message holds the results generated by processing a trace according to a `TraceSummarySpec`.

Key components:

*   **`metric` (repeated [`TraceMetricV2`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/perfetto/protos/perfetto/trace_summary/v2_metric.proto;l=240?q=tracemetricv2&sq=))**: Contains the computed results for each metric defined in the spec. See Metric Results (`TraceMetricV2`) for details.
*   **`metadata` (repeated `Metadata`)**: A list of key-value pairs representing trace-wide metadata. This data is populated by executing a `PerfettoSqlStructuredQuery` from `TraceSummarySpec.query` that has been explicitly designated for metadata computation (e.g., via `metadata_query_id` or a corresponding shell flag). This can include information like the device the trace was collected on, OS version, etc., providing context for the metrics.
    *   `key` (string)
    *   `value` (string)

## Metric Definition

A single metric is defined using the `TraceMetricV2Spec` message. It specifies what data to extract and how to structure it as a value with associated dimensions.

Core fields:

*   **`id` (string, required)**: A unique identifier for the metric (e.g., "cpu_usage_per_process"). Conventionally, this is lowercase with underscores.
*   **`dimensions` (repeated string) / `dimensions_specs` (repeated `DimensionSpec`)**: Defines the columns from the query result that will act as dimensions for the metric. You should define either `dimensions` (if types can be inferred or are not critical for the spec) or `dimensions_specs` (to explicitly define types).
    *   `DimensionSpec` allows specifying the `name` and `type` (`DimensionType`: `STRING`, `INT64`, `DOUBLE`) of each dimension.
    *   For any given combination of dimension values, there should be exactly one metric value.
*   **`value` (string, required)**: The column from the query result that contains the numerical value of the metric. This column must contain integers, doubles, or nulls. Strings are not supported as values; consider making string data a dimension and counting occurrences if needed.
*   **`query` (`PerfettoSqlStructuredQuery`, required)**: The structured query that computes the data for this metric. See Structured Queries (`PerfettoSqlStructuredQuery`) for a detailed explanation.

### Example: Memory Usage Per Process

This example shows how to define a metric for average memory usage (RSS + Swap) per process.


```protobuf
// In TraceSummarySpec's metric_spec field:
metric_spec {
  id: "memory_per_process"
  dimensions_specs {
    name: "process_name"
    type: STRING
  }
  value: "avg_rss_and_swap" // This name must match an output column of the query
  query: {
    table: {
      table_name: "memory_rss_and_swap_per_process" // From PerfettoSQL stdlib
      module_name: "linux.memory.process"
    }
    group_by: {
      column_names: "process_name" // This will be the dimension
      aggregates: {
        column_name: "rss_and_swap"
        op: DURATION_WEIGHTED_MEAN
        result_column_name: "avg_rss_and_swap" // This will be the value
      }
    }
    // Optional: select_columns can explicitly rename/select columns.
    // If group_by output names match 'dimensions_specs.name' and 'value',
    // this might not be strictly needed.
    select_columns { column_name: "process_name" }
    select_columns { column_name: "avg_rss_and_swap" }
  }
}
```

The same metric can be defined shorter by replacing `dimensions_spec` with `dimensions` and skipping `select_columns` field.
```protobuf
metric_spec {
  id: "memory_per_process"
  dimensions: "process_name"
  value: "avg_rss_and_swap"
  query: {
    table: {
      table_name: "memory_rss_and_swap_per_process"
      module_name: "linux.memory.process"
    }
    group_by: {
      column_names: "process_name"
      aggregates: {
        column_name: "rss_and_swap"
        op: DURATION_WEIGHTED_MEAN
        result_column_name: "avg_rss_and_swap"
      }
    }
  }
}
```

## Metric Result

The `TraceMetricV2` message holds the computed output for a single metric defined by a `TraceMetricV2Spec`.

Key components:

*   **`row` (repeated `MetricRow`)**: Each row represents a unique combination of dimension values and its corresponding metric value.
    *   `MetricRow`:
        *   `value` (double, optional): The numerical value of the metric for this dimension set. If the underlying SQL value is NULL, the row might not be emitted.
        *   `dimension` (repeated `Dimension`): The values for each dimension, in the order specified by `spec.dimensions` or `spec.dimensions_specs`.
            *   `Dimension` is a `oneof` type that can hold `string_value`, `int64_value`, `double_value`, or `null_value`.
*   **`spec` (`TraceMetricV2Spec`, optional)**: An echo of the `TraceMetricV2Spec` that was used to compute this metric. This is useful for interpreting the `row` data, as it contains the dimension and value names.

### Example Output

For the `memory_per_process` metric defined above, a `TraceMetricV2` output might look like:

```protobuf
// In TraceSummary's metric field:
metric {
  // The metric spec is always included.
  spec {
    id: "memory_per_process"
    dimensions: "process_name"
    value: "avg_rss_and_swap"
    query: {
      table: {
        table_name: "memory_rss_and_swap_per_process"
        module_name: "linux.memory.process"
      }
      group_by: {
        column_names: "process_name"
        aggregates: {
          column_name: "rss_and_swap"
          op: DURATION_WEIGHTED_MEAN
          result_column_name: "avg_rss_and_swap"
        }
      }
    }
  }
  // Metric results
  row {
    value: 123456.789
    dimension {
      string_value: "com.example.app"
    }
  }
  row {
    value: 98765.432
    dimension {
      string_value: "system_server"
    }
  }
  // Additional rows for other processes would follow.

}
```

## Structured Queries

The `PerfettoSqlStructuredQuery` message provides a structured way to define PerfettoSQL queries. It aims to codify common query patterns for easier machine consumption and tooling, while still being somewhat human-readable. This is the core mechanism for fetching and processing data for metrics.

A `PerfettoSqlStructuredQuery` is built by defining a data `source` and then optionally applying `filters`, `group_by` operations, and `select_columns` transformations.

*   **`id` (string, optional)**: An opaque identifier for the query (e.g., "cuj_intervals"). Recommended for clarity and required if the query is referenced by `inner_query_id` from another query.

### Query Sources

One of the following `source` fields must be specified:

*   **`table` (`Table`)**: Specifies a PerfettoSQL table or view as the source.
    *   `table_name` (string, required): Name of the table/view (e.g., "slice", "thread_state").
    *   `module_name` (string, optional): Module if the table is not in the global scope (e.g., "linux.cpu.freq").
    *   `column_names` (repeated string, required): Declares all columns from this table that the query intends to use (for selection, filtering, or aggregation).
*   **`sql` (`Sql`)**: Allows using an arbitrary SQL query string.
    *   `sql` (string, required): The `SELECT` statement.
    *   `column_names` (repeated string, required): Output columns of the SQL query.
    *   `preamble` (string, optional): SQL to run before the main `sql` query (e.g., for `CREATE PERFETTO VIEW` or other setup).
*   **`simple_slices` (`SimpleSlices`)**: A convenience for querying the `slice` table with common filters.
    *   Produces columns: `id`, `ts`, `dur`, `slice_name`, `thread_name`, `process_name`, `track_name`.
    *   Allows glob filtering on `slice_name_glob`, `thread_name_glob`, `process_name_glob`, `track_name_glob` fields.
*   **`inner_query` (`PerfettoSqlStructuredQuery`)**: Nests another structured query as the source. Useful for building complex queries step-by-step.
*   **`inner_query_id` (string)**: References a shared `PerfettoSqlStructuredQuery` (by its `id`) defined elsewhere, typically in the `TraceSummarySpec.query` list.
*   **`interval_intersect` (`IntervalIntersect`)**: This source type is powerful for analyzing data within specific time windows or "Critical User Journeys" (CUJs). It performs a time-based intersection of a primary data source (the `base` query) with one or more sets of time intervals (the `interval_intersect` queries).
    *   **`base` (`PerfettoSqlStructuredQuery`)**: This is your main data source (e.g., CPU scheduling data, memory counters over time, specific slice events). It must effectively provide `id`, `ts` (timestamp), and `dur` (duration) columns for its events or intervals.
    *   **`interval_intersect` (repeated `PerfettoSqlStructuredQuery`)**: These queries define the time intervals against which the `base` data will be filtered. Each of these queries must also effectively provide `id`, `ts`, and `dur` columns, representing a set of time intervals (e.g., CUJ start/end slices, specific application states).
    *   **Operation**:
        *   An event or interval from the `base` query is included in the output only if its time span overlaps with at least one interval from *each* of the provided `interval_intersect` queries.
        *   If a `base` row overlaps with multiple combinations of intervals from the `interval_intersect` queries, multiple output rows may be generated for that single `base` row, each corresponding to a unique overlapping combination.
        *   The `dur` column in the output is adjusted to reflect the actual duration of the overlap between the `base` interval and the intersecting intervals.
        *   Columns from both the `base` query and all `interval_intersect` queries are carried forward to the output, allowing for rich dimensional analysis. If column names conflict, they may be disambiguated or aliasing might be necessary in subsequent `select_columns` operations.
    *   **Use Cases**:
        *   Calculating CPU usage of specific threads only during defined CUJ periods.
        *   Analyzing memory consumption of a process while a particular user interaction (defined by a slice) is active.
        *   Finding specific system events (from `base`) that occur only when multiple conditions (defined by different `interval_intersect` queries, e.g., "app in foreground" AND "scrolling activity") are simultaneously true.

### Query Operations (Applied after source)

These operations are applied sequentially to the data produced by the source:

*   **`filters` (repeated `Filter`)**: A list of conditions ANDed together to filter rows.
    *   `Filter`:
        *   `column_name` (string, required).
        *   `op` (enum `Operator`): Specifies the comparison. Possible values:
            *   `EQUAL` (SQL: `=`)
            *   `NOT_EQUAL` (SQL: `!=` or `<>`)
            *   `LESS_THAN` (SQL: `<`)
            *   `LESS_THAN_EQUAL` (SQL: `<=`)
            *   `GREATER_THAN` (SQL: `>`)
            *   `GREATER_THAN_EQUAL` (SQL: `>=`)
            *   `GLOB` (SQL: `GLOB`) (Unix-style glob matching, typically for string columns)
            *   `IS_NULL` (SQL: `IS NULL`)
            *   `IS_NOT_NULL` (SQL: `IS NOT NULL`)
        *   `string_rhs`, `double_rhs`, `int64_rhs` (repeated): Values for the right-hand side of the operation. If multiple values are provided for a given type (e.g., multiple `string_rhs`), they are typically ORed (forming an "IN" or "GLOB IN" condition). For `IS_NULL` and `IS_NOT_NULL`, these are not used.
*   **`group_by` (`GroupBy`)**: Groups rows based on specified column values and applies aggregate functions.
    *   `column_names` (repeated string, required): Columns to group by. These columns are passed through to the output.
    *   `aggregates` (repeated `Aggregate`): Aggregation functions to apply to each group.
        *   `Aggregate`:
            *   `column_name` (string): Source column to aggregate.
            *   `op` (enum `Op`): Specifies the aggregation function. Possible values:
                *   `COUNT` (SQL: `COUNT()`)
                *   `SUM` (SQL: `SUM()`)
                *   `MIN` (SQL: `MIN()`)
                *   `MAX` (SQL: `MAX()`)
                *   `MEAN` (SQL: `AVG()`) (average)
                *   `MEDIAN` (SQL: `MEDIAN()`)
                *   `DURATION_WEIGHTED_MEAN` (No direct SQL equivalent, custom PerfettoSQL function; calculates an average weighted by a duration, typically requiring a `dur` column in the grouped data)
            *   `result_column_name` (string): Name for the resulting aggregate column in the output.
*   **`select_columns` (repeated `SelectColumn`)**: Selects and optionally renames columns for the final output of this structured query.
    *   If not specified, all columns from the preceding stage (source, after filtering, or after `group_by`) are output.
    *   `SelectColumn`:
        *   `column_name` (string, required): Existing column name from the input to this stage.
        *   `alias` (string, optional): New name for the column in the output.

### Example: CPU Time during a Specific CUJ Slice

This example demonstrates using `interval_intersect` to find total CPU time for thread `bar` within the duration of a "baz_*" slices of process "system_server".

```protobuf
// This would be part of a TraceMetricV2Spec.query field.
// Assume the TraceMetricV2Spec has:
//   id: "bar_cpu_time_during_baz_cujs"
//   value: "total_cpu_time"
//   dimensions_specs: { name: "thread_name"; type: STRING }

query: {
  interval_intersect: {
     base: {
       table: {
         table_name: "thread_slice_cpu_time"
         module_name: "linux.memory.process"
       }
       filters: {
         column_name: "thread_name"
         op: EQUAL
         string_rhs: "bar"
       }
     }
     interval_intersect: {
       simple_slices: {
         slice_name_glob: "baz_*"
         process_name_glob: "system_server"
       }
     }
  }
  group_by: {
    aggregates: {
      column_name: "cpu_time"
      op: SUM
      result_column_name: "total_cpu_time"
    }
  }
}
```

## How to Use

Trace summaries can be computed using different Perfetto tools, primarily through the `trace_processor_shell` for command-line operations and the Python API for programmatic access.

### Command-Line with [`trace_processor_shell`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/perfetto/src/trace_processor/trace_processor_shell.cc;l=787-820?q=trace_processor_shell)

The `trace_processor_shell` allows you to compute trace summaries from a trace file using dedicated flags. There are two main approaches:

To control which v2 metrics are computed, use the `--summary-metrics-v2` flag. These metrics must be defined in a spec file provided via the `--summary-spec` `YOUR_SPEC_FILE` flag, or be built-in/registered.
The `--summary-spec` flag tells `trace_processor_shell` where to find your `TraceSummarySpec` definition. The format of this spec file is determined based on its extension:
*   If the file extension is `.textproto`, it is parsed as a text-format protobuf.
*   If the file extension is `.pb`, it is parsed as a binary protobuf.
*   For other extensions, `trace_processor_shell` uses heuristics to determine the format (typically attempting text proto first).
*   **Run specific metrics by ID:** Provide a comma-separated list of metric IDs.
    ```bash
    trace_processor_shell --summary --summary-spec YOUR_SPEC_FILE --summary-metrics-v2 METRIC_ID_1,METRIC_ID_2 TRACE_FILE
    ```
    *Example:*
    ```bash
    trace_processor_shell --summary --summary-spec my_spec.textproto --summary-metrics-v2 cpu_util,mem_usage my_trace.perfetto-trace
    ```
*   **Run all metrics defined in the spec:** Use the keyword `all`.
    ```bash
    trace_processor_shell --summary --summary-spec YOUR_SPEC_FILE --summary-metrics-v2 all TRACE_FILE
    ```
*   **Run only metadata queries (no metrics):** If you only want to compute metadata (using `--summary-metadata-query ID_OF_METADATA_QUERY` which must also be specified if metadata is desired) and no metrics, simply omit the `--summary-metrics-v2` flag.

**Output Format:**
The serialization format of the resulting `TraceSummary` proto is controlled by the `--summary-format` flag:
*   `--summary-format text`: Outputs the summary as a human-readable text protobuf. This is the default if the flag is not specified.
*   `--summary-format binary`: Outputs the summary as a binary protobuf.

### [`TraceProcessor`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/perfetto/python/perfetto/trace_processor/api.py;l=169?q=trace_processor%2Fapi.py) with Python API

For programmatic workflows, Perfetto provides a Python API. The `TraceProcessor` class in the `perfetto.trace_processor.api` module offers a `trace_summary` method to compute summaries.

The HTTP interface is also available, though its direct high-level support for running full trace summaries might be less explicit compared to the shell or Python API.

The `TraceProcessor` class in the Perfetto Python library (`perfetto.trace_processor.api`) offers a `trace_summary` method to compute summaries.

**Method Signature:**

```python
def trace_summary(self,
                  specs: List[Union[str, bytes]],
                  metric_ids: Optional[List[str]] = None,
                  metadata_query_id: Optional[str] = None):
```

*   **`specs: List[Union[str, bytes]]`**: A list of `TraceSummarySpec` definitions. Each element in the list can be:
    *   A **string** containing a `TraceSummarySpec` in text protobuf format.
    *   A **bytes object** representing a serialized `TraceSummarySpec` protobuf message.
    *   You can mix both types in the list. The `metric_spec` and `query` fields from all provided specs are effectively concatenated by the trace processor to form the complete specification.
*   **`metric_ids: Optional[List[str]] = None`**: An optional list of metric IDs (strings).
    *   If provided, only the metrics whose IDs are present in this list (and are defined within the `specs`) will be computed and included in the result.
    *   If `None` (the default) all metrics defined in the `specs` will be computed.
    *   If empty list, no metrics will be computed.
*   **`metadata_query_id: Optional[str] = None`**: An optional string specifying the `id` of a `PerfettoSqlStructuredQuery` (which must be defined in one of the `specs`) to be executed for generating trace-wide metadata. This query is expected to output "key" and "value" columns.

**Example Usage:**

```python
from perfetto.trace_processor.api import TraceProcessor
from perfetto.trace_processor.api import TraceProcessorConfig

# Assume 'trace_file_path' is the path to your .perfetto-trace file
# Assume 'shell_path' is the path to your trace_processor_shell binary
config = TraceProcessorConfig(bin_path=shell_path)
tp = TraceProcessor(trace=trace_file_path, config=config)

# Define a TraceSummarySpec as a textproto string
spec_textproto = """
metric_spec {
  id: "example_metric"
  value: "dur"
  query {
    simple_slices {
      slice_name_glob: "MySlice*"
    }
  }
}
query {
  id: "device_info_query"
  sql {
    sql: "SELECT 'device_name' AS key, 'Pixel Test' AS value"
    column_names: "key"
    column_names: "value"
  }
}
"""

# Compute the summary
# This will compute "example_metric" and use "device_info_query" for metadata.
summary_proto = tp.trace_summary(
    specs=[spec_textproto],
    metric_ids=["example_metric"],
    metadata_query_id="device_info_query"
)

# summary_proto is a TraceSummary protobuf object
print(f"Computed metric ID: {summary_proto.metric[0].spec.id}")
if summary_proto.metadata:
    print(f"Metadata: {summary_proto.metadata[0].key} = {summary_proto.metadata[0].value}")

tp.close()
```