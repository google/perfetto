# Trace Summary

The Perfetto trace processor allows for the computation of "trace summaries," which are structured representations of important properties extracted from a trace. These summaries are defined by a specification and result in a corresponding output proto, making them consumable by various tools and systems.

## Overview

The trace summary system revolves around two main protobuf messages located in `protos/perfetto/trace_summary/file.proto`:

*   **`TraceSummarySpec`**: Defines *what* and *how* to compute from the trace.
*   **`TraceSummary`**: Contains the *results* of the computation.

## Summary Specification

The `TraceSummarySpec` message is the top-level proto used to configure how a trace should be summarized. It acts as a container for one or more metric specifications and shared queries.

Key components:

*   **`metric_spec` (repeated `TraceMetricV2Spec`)**: Defines individual metrics to be computed. See Defining Metrics (`TraceMetricV2Spec`) for details.
*   **`query` (repeated `PerfettoSqlStructuredQuery`)**: Specifies structured queries. These queries serve two purposes:
    *   **Shared Queries for Metrics**: They can be referenced by the `inner_query_id` field within a `metric_spec.query`. This allows a single, complex query definition to be reused across multiple metrics.
    *   **Trace-Wide Metadata**: If a `PerfettoSqlStructuredQuery` in this list is *not* referenced by any `metric_spec`, it is executed to compute trace-wide metadata. Such a query is expected to return rows with two columns, typically named "key" and "value" (both strings or convertible to strings). Each row from the query's result will become a `Metadata` entry in the `TraceSummary.metadata` list.

## Summary Output

The `TraceSummary` message holds the results generated by processing a trace according to a `TraceSummarySpec`.

Key components:

*   **`metric` (repeated `TraceMetricV2`)**: Contains the computed results for each metric defined in the spec. See Metric Results (`TraceMetricV2`) for details.
*   **`metadata` (repeated `Metadata`)**: A list of key-value pairs representing trace-wide metadata. This data is populated by executing the `PerfettoSqlStructuredQuery` entries in `TraceSummarySpec.query` that are designated for metadata computation (as described above). This can include information like the device the trace was collected on, OS version, etc., providing context for the metrics.
    *   `key` (string)
    *   `value` (string)

## Metric Definition

A single metric is defined using the `TraceMetricV2Spec` message. It specifies what data to extract and how to structure it as a value with associated dimensions.

Core fields:

*   **`id` (string, required)**: A unique identifier for the metric (e.g., "cpu_usage_per_process"). Conventionally, this is lowercase with underscores.
*   **`dimensions` (repeated string) / `dimensions_specs` (repeated `DimensionSpec`)**: Defines the columns from the query result that will act as dimensions for the metric. You should define either `dimensions` (if types can be inferred or are not critical for the spec) or `dimensions_specs` (to explicitly define types).
    *   `DimensionSpec` allows specifying the `name` and `type` (`DimensionType`: `STRING`, `INT64`, `DOUBLE`) of each dimension.
    *   For any given combination of dimension values, there should be exactly one metric value.
*   **`value` (string, required)**: The column from the query result that contains the numerical value of the metric. This column must contain integers, doubles, or nulls. Strings are not supported as values; consider making string data a dimension and counting occurrences if needed.
*   **`query` (`PerfettoSqlStructuredQuery`, required)**: The structured query that computes the data for this metric. See Structured Queries (`PerfettoSqlStructuredQuery`) for a detailed explanation.

### Example: Memory Usage Per Process

This example shows how to define a metric for average memory usage (RSS + Swap) per process.

```protobuf
// In TraceSummarySpec's metric_spec field:
metric_spec {
  id: "memory_per_process"
  dimensions_specs {
    name: "process_name"
    type: STRING
  }
  value: "avg_rss_and_swap" // This name must match an output column of the query
  query: {
    table: {
      table_name: "memory_rss_and_swap_per_process" // From PerfettoSQL stdlib
      module_name: "linux.memory.process"
      // Declare all columns from the source table that are used by the query
      // for filtering, grouping, or aggregation.
      column_names: "upid"
      column_names: "process_name"
      column_names: "rss_and_swap"
      column_names: "dur" // Needed for DURATION_WEIGHTED_MEAN
    }
    group_by: {
      column_names: "process_name" // This will be the dimension
      aggregates: {
        column_name: "rss_and_swap"
        op: DURATION_WEIGHTED_MEAN
        result_column_name: "avg_rss_and_swap" // This will be the value
      }
    }
    // Optional: select_columns can explicitly rename/select columns.
    // If group_by output names match 'dimensions_specs.name' and 'value',
    // this might not be strictly needed.
    select_columns { column_name: "process_name" }
    select_columns { column_name: "avg_rss_and_swap" }
  }
}
```

## Metric Result

The `TraceMetricV2` message holds the computed output for a single metric defined by a `TraceMetricV2Spec`.

Key components:

*   **`row` (repeated `MetricRow`)**: Each row represents a unique combination of dimension values and its corresponding metric value.
    *   `MetricRow`:
        *   `value` (double, optional): The numerical value of the metric for this dimension set. If the underlying SQL value is NULL, the row might not be emitted.
        *   `dimension` (repeated `Dimension`): The values for each dimension, in the order specified by `spec.dimensions` or `spec.dimensions_specs`.
            *   `Dimension` is a `oneof` type that can hold `string_value`, `int64_value`, `double_value`, or `null_value`.
*   **`spec` (`TraceMetricV2Spec`, optional)**: An echo of the `TraceMetricV2Spec` that was used to compute this metric. This is useful for interpreting the `row` data, as it contains the dimension and value names.

### Example Output

For the `memory_per_process` metric defined above, a `TraceMetricV2` output might look like:

```protobuf
// In TraceSummary's metric field:
metric {
  row {
    value: 123456.789
    dimension {
      string_value: "com.example.app"
    }
  }
  row {
    value: 98765.432
    dimension {
      string_value: "system_server"
    }
  }
  // Additional rows for other processes would follow.
  spec {
    id: "memory_per_process"
    dimensions_specs {
      name: "process_name"
      type: STRING
    }
    value: "avg_rss_and_swap"
    query: {
      table: {
        table_name: "memory_rss_and_swap_per_process"
        module_name: "linux.memory.process"
        column_names: "upid"
        column_names: "process_name"
        column_names: "rss_and_swap"
        column_names: "dur"
      }
      group_by: {
        column_names: "process_name"
        aggregates: {
          column_name: "rss_and_swap"
          op: DURATION_WEIGHTED_MEAN
          result_column_name: "avg_rss_and_swap"
        }
      }
      select_columns { column_name: "process_name" }
      select_columns { column_name: "avg_rss_and_swap" }
    }
  }
}
```

## Structured Queries

The `PerfettoSqlStructuredQuery` message provides a structured way to define PerfettoSQL queries. It aims to codify common query patterns for easier machine consumption and tooling, while still being somewhat human-readable. This is the core mechanism for fetching and processing data for metrics.

A `PerfettoSqlStructuredQuery` is built by defining a data `source` and then optionally applying `filters`, `group_by` operations, and `select_columns` transformations.

*   **`id` (string, optional)**: An opaque identifier for the query (e.g., "cuj_intervals"). Recommended for clarity and required if the query is referenced by `inner_query_id` from another query.

### Query Sources

One of the following `source` fields must be specified:

*   **`table` (`Table`)**: Specifies a PerfettoSQL table or view as the source.
    *   `table_name` (string, required): Name of the table/view (e.g., "slice", "thread_state").
    *   `module_name` (string, optional): Module if the table is not in the global scope (e.g., "linux.cpu.freq").
    *   `column_names` (repeated string, required): Declares all columns from this table that the query intends to use (for selection, filtering, or aggregation).
*   **`sql` (`Sql`)**: Allows using an arbitrary SQL query string.
    *   `sql` (string, required): The `SELECT` statement.
    *   `column_names` (repeated string, required): Output columns of the SQL query.
    *   `preamble` (string, optional): SQL to run before the main `sql` query (e.g., for `CREATE PERFETTO VIEW` or other setup).
*   **`simple_slices` (`SimpleSlices`)**: A convenience for querying the `slice` table with common filters.
    *   Produces columns: `id`, `ts`, `dur`, `slice_name`, `thread_name`, `process_name`, `track_name`.
    *   Allows glob filtering on `slice_name_glob`, `thread_name_glob`, `process_name_glob`, `track_name_glob`.
*   **`inner_query` (`PerfettoSqlStructuredQuery`)**: Nests another structured query as the source. Useful for building complex queries step-by-step or aliasing.
*   **`inner_query_id` (string)**: References a shared `PerfettoSqlStructuredQuery` (by its `id`) defined elsewhere, typically in the `TraceSummarySpec.query` list.
*   **`interval_intersect` (`IntervalIntersect`)**: Performs a time-based intersection of a `base` query with one or more `interval_intersect` queries.
    *   `base` (`PerfettoSqlStructuredQuery`): The main data query. Must effectively provide `id`, `ts`, and `dur` columns.
    *   `interval_intersect` (repeated `PerfettoSqlStructuredQuery`): Queries defining intervals for intersection. Each must also effectively provide `id`, `ts`, and `dur`.
    *   The `dur` column of the output is adjusted to the overlapping duration. Rows from `base` are included if they overlap with at least one interval from *each* of the `interval_intersect` queries.

### Query Operations (Applied after source)

These operations are applied sequentially to the data produced by the source:

*   **`filters` (repeated `Filter`)**: A list of conditions ANDed together to filter rows.
    *   `Filter`:
        *   `column_name` (string, required).
        *   `op` (enum `Operator`): `EQUAL`, `NOT_EQUAL`, `LESS_THAN`, `GLOB`, `IS_NULL`, etc.
        *   `string_rhs`, `double_rhs`, `int64_rhs` (repeated): Values for the right-hand side of the operation. If multiple values are provided for a given type (e.g., multiple `string_rhs`), they are typically ORed (forming an "IN" or "GLOB IN" condition).
*   **`group_by` (`GroupBy`)**: Groups rows based on specified column values and applies aggregate functions.
    *   `column_names` (repeated string, required): Columns to group by. These columns are passed through to the output.
    *   `aggregates` (repeated `Aggregate`): Aggregation functions to apply to each group.
        *   `Aggregate`:
            *   `column_name` (string): Source column to aggregate.
            *   `op` (enum `Op`): `COUNT`, `SUM`, `MIN`, `MAX`, `MEAN`, `MEDIAN`, `DURATION_WEIGHTED_MEAN`.
            *   `result_column_name` (string): Name for the resulting aggregate column in the output.
*   **`select_columns` (repeated `SelectColumn`)**: Selects and optionally renames columns for the final output of this structured query.
    *   If not specified, all columns from the preceding stage (source, after filtering, or after `group_by`) are output.
    *   `SelectColumn`:
        *   `column_name` (string, required): Existing column name from the input to this stage.
        *   `alias` (string, optional): New name for the column in the output.

### Example: CPU Time during a Specific CUJ Slice

This example demonstrates using `interval_intersect` to find total CPU time for specific `slice_name` events occurring within the duration of a "baz_cuj" slice.

```protobuf
// This would be part of a TraceMetricV2Spec.query field.
// Assume the TraceMetricV2Spec has:
//   id: "foo_cpu_time_during_baz_cuj"
//   value: "total_cpu_time"
//   dimensions_specs: { name: "cuj_slice_name"; type: STRING }

query: {
  id: "cpu_time_in_baz_cuj_query"
  interval_intersect: {
    base: { // CPU time data for "foo_slice"
      table: {
        // Assuming a table like 'slice_cpu_time' exists from a module,
        // providing CPU time per slice.
        table_name: "slice_cpu_time" // This is a hypothetical table name
        // module_name: "some.cpu.module" // Specify if it's in a module
        column_names: "id"
        column_names: "ts"
        column_names: "dur"
        column_names: "slice_name"
        column_names: "cpu_time" // The actual CPU time value for the slice
      }
      filters: {
        column_name: "slice_name"
        op: EQUAL
        string_rhs: "foo_slice" // We are interested in CPU time of "foo_slice"
      }
    }
    interval_intersect: { // Intervals defining the "baz_cuj"
      simple_slices: {
        slice_name_glob: "baz_cuj"
        // process_name_glob: "com.example.app" // Optionally filter CUJ by process
      }
      // Select the CUJ slice name to use as a dimension.
      // Also ensure id, ts, dur are selected for the intersection logic to work.
      select_columns: { column_name: "slice_name"; alias: "cuj_slice_name" }
      select_columns: { column_name: "id" }
      select_columns: { column_name: "ts" }
      select_columns: { column_name: "dur" }
    }
  }
  // After intersection, we have rows of "foo_slice" that occurred during "baz_cuj",
  // with 'cpu_time' from "foo_slice" and 'cuj_slice_name' from "baz_cuj".
  // The 'dur' column is the intersected duration.
  group_by: {
    column_names: "cuj_slice_name" // Group by each instance of the CUJ
    aggregates: {
      column_name: "cpu_time" // Sum the cpu_time from the intersected "foo_slice"
      op: SUM
      result_column_name: "total_cpu_time" // This matches TraceMetricV2Spec.value
    }
  }
  // Ensure final output columns match metric spec dimensions and value.
  select_columns: { column_name: "cuj_slice_name" }
  select_columns: { column_name: "total_cpu_time" }
}

## How to Use

The primary method for generating trace summaries is via the `trace_processor_shell`.

### Using `trace_processor_shell`

`trace_processor_shell` allows you to compute trace summaries from a trace file. There are two main approaches:

1.  **Provide a `TraceSummarySpec` File:**
    You can define the entire summary specification in a file, detailing all metrics and queries.
    *   **Command:**
        ```bash
        trace_processor_shell --summary-spec YOUR_SPEC_FILE TRACE_FILE
        ```
    *   **`YOUR_SPEC_FILE` Format:**
        *   Use a `.textproto` extension if the file contains the `TraceSummarySpec` in text protobuf format.
        *   Use a `.pb` extension for binary protobuf format.
    *   **Example:**
        ```bash
        trace_processor_shell --summary-spec my_summary.textproto my_trace.perfetto-trace
        ```
        This command processes `my_trace.perfetto-trace` using the specification in `my_summary.textproto`. The output will be a `TraceSummary` message, typically printed in text protobuf format.

2.  **Run Specific v2 Metrics by ID:**
    If you have v2 metrics that are known to the trace processor (e.g., built-in or registered via extensions), you can run them by their IDs.
    *   **Command:**
        ```bash
        trace_processor_shell --summary-metrics-v2 METRIC_ID_1,METRIC_ID_2,... TRACE_FILE
        ```
    *   **Example:**
        ```bash
        trace_processor_shell --summary-metrics-v2 cpu_usage_overall,peak_memory_usage my_trace.perfetto-trace
        ```
        This computes the metrics "cpu_usage_overall" and "peak_memory_usage".

**Output:**
By default, `trace_processor_shell` usually outputs the `TraceSummary` in text protobuf format. You can check `trace_processor_shell --help` for options to control the output format if needed.

### Programmatic Interfaces

Perfetto also offers a Python API (`TraceProcessor`) and an HTTP interface. While these provide powerful ways to query trace data, direct high-level functions to run a full `TraceSummarySpec` (like the shell's `--summary-spec`) may not be as explicit. Advanced users can use these interfaces to execute the underlying SQL queries defined within a `TraceSummarySpec` and process the results programmatically.
