// AUTOGENERATED - DO NOT EDIT
// ---------------------------
// This file has been generated by
// AOSP://external/perfetto/tools/gen_merged_protos
// merging the perfetto config protos.
// This fused proto is intended to be copied in:
//  - Android tree, for statsd.
//  - Google internal repos.

syntax = "proto2";

package perfetto.protos;

// Begin of protos/perfetto/common/android_log_constants.proto

// Values from NDK's android/log.h.
enum AndroidLogId {
  LID_DEFAULT = 0;  // MAIN.
  LID_RADIO = 1;
  LID_EVENTS = 2;
  LID_SYSTEM = 3;
  LID_CRASH = 4;
  LID_STATS = 5;
  LID_SECURITY = 6;
  LID_KERNEL = 7;
}

enum AndroidLogPriority {
  PRIO_UNSPECIFIED = 0;
  PRIO_UNUSED = 1;  // _DEFAULT, but should never be seen in logs.
  PRIO_VERBOSE = 2;
  PRIO_DEBUG = 3;
  PRIO_INFO = 4;
  PRIO_WARN = 5;
  PRIO_ERROR = 6;
  PRIO_FATAL = 7;
}

// End of protos/perfetto/common/android_log_constants.proto

// Begin of protos/perfetto/common/sys_stats_counters.proto

// When editing entries here remember also to update "sys_stats_counters.h" with
// the corresponding string definitions for the actual /proc files parser.

// Counter definitions for Linux's /proc/meminfo.
enum MeminfoCounters {
  MEMINFO_UNSPECIFIED = 0;
  MEMINFO_MEM_TOTAL = 1;
  MEMINFO_MEM_FREE = 2;
  MEMINFO_MEM_AVAILABLE = 3;
  MEMINFO_BUFFERS = 4;
  MEMINFO_CACHED = 5;
  MEMINFO_SWAP_CACHED = 6;
  MEMINFO_ACTIVE = 7;
  MEMINFO_INACTIVE = 8;
  MEMINFO_ACTIVE_ANON = 9;
  MEMINFO_INACTIVE_ANON = 10;
  MEMINFO_ACTIVE_FILE = 11;
  MEMINFO_INACTIVE_FILE = 12;
  MEMINFO_UNEVICTABLE = 13;
  MEMINFO_MLOCKED = 14;
  MEMINFO_SWAP_TOTAL = 15;
  MEMINFO_SWAP_FREE = 16;
  MEMINFO_DIRTY = 17;
  MEMINFO_WRITEBACK = 18;
  MEMINFO_ANON_PAGES = 19;
  MEMINFO_MAPPED = 20;
  MEMINFO_SHMEM = 21;
  MEMINFO_SLAB = 22;
  MEMINFO_SLAB_RECLAIMABLE = 23;
  MEMINFO_SLAB_UNRECLAIMABLE = 24;
  MEMINFO_KERNEL_STACK = 25;
  MEMINFO_PAGE_TABLES = 26;
  MEMINFO_COMMIT_LIMIT = 27;
  MEMINFO_COMMITED_AS = 28;
  MEMINFO_VMALLOC_TOTAL = 29;
  MEMINFO_VMALLOC_USED = 30;
  MEMINFO_VMALLOC_CHUNK = 31;
  MEMINFO_CMA_TOTAL = 32;
  MEMINFO_CMA_FREE = 33;
}

// Counter definitions for Linux's /proc/vmstat.
enum VmstatCounters {
  VMSTAT_UNSPECIFIED = 0;
  VMSTAT_NR_FREE_PAGES = 1;
  VMSTAT_NR_ALLOC_BATCH = 2;
  VMSTAT_NR_INACTIVE_ANON = 3;
  VMSTAT_NR_ACTIVE_ANON = 4;
  VMSTAT_NR_INACTIVE_FILE = 5;
  VMSTAT_NR_ACTIVE_FILE = 6;
  VMSTAT_NR_UNEVICTABLE = 7;
  VMSTAT_NR_MLOCK = 8;
  VMSTAT_NR_ANON_PAGES = 9;
  VMSTAT_NR_MAPPED = 10;
  VMSTAT_NR_FILE_PAGES = 11;
  VMSTAT_NR_DIRTY = 12;
  VMSTAT_NR_WRITEBACK = 13;
  VMSTAT_NR_SLAB_RECLAIMABLE = 14;
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15;
  VMSTAT_NR_PAGE_TABLE_PAGES = 16;
  VMSTAT_NR_KERNEL_STACK = 17;
  VMSTAT_NR_OVERHEAD = 18;
  VMSTAT_NR_UNSTABLE = 19;
  VMSTAT_NR_BOUNCE = 20;
  VMSTAT_NR_VMSCAN_WRITE = 21;
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22;
  VMSTAT_NR_WRITEBACK_TEMP = 23;
  VMSTAT_NR_ISOLATED_ANON = 24;
  VMSTAT_NR_ISOLATED_FILE = 25;
  VMSTAT_NR_SHMEM = 26;
  VMSTAT_NR_DIRTIED = 27;
  VMSTAT_NR_WRITTEN = 28;
  VMSTAT_NR_PAGES_SCANNED = 29;
  VMSTAT_WORKINGSET_REFAULT = 30;
  VMSTAT_WORKINGSET_ACTIVATE = 31;
  VMSTAT_WORKINGSET_NODERECLAIM = 32;
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33;
  VMSTAT_NR_FREE_CMA = 34;
  VMSTAT_NR_SWAPCACHE = 35;
  VMSTAT_NR_DIRTY_THRESHOLD = 36;
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37;
  VMSTAT_PGPGIN = 38;
  VMSTAT_PGPGOUT = 39;
  VMSTAT_PGPGOUTCLEAN = 40;
  VMSTAT_PSWPIN = 41;
  VMSTAT_PSWPOUT = 42;
  VMSTAT_PGALLOC_DMA = 43;
  VMSTAT_PGALLOC_NORMAL = 44;
  VMSTAT_PGALLOC_MOVABLE = 45;
  VMSTAT_PGFREE = 46;
  VMSTAT_PGACTIVATE = 47;
  VMSTAT_PGDEACTIVATE = 48;
  VMSTAT_PGFAULT = 49;
  VMSTAT_PGMAJFAULT = 50;
  VMSTAT_PGREFILL_DMA = 51;
  VMSTAT_PGREFILL_NORMAL = 52;
  VMSTAT_PGREFILL_MOVABLE = 53;
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54;
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55;
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56;
  VMSTAT_PGSTEAL_DIRECT_DMA = 57;
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58;
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59;
  VMSTAT_PGSCAN_KSWAPD_DMA = 60;
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61;
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62;
  VMSTAT_PGSCAN_DIRECT_DMA = 63;
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64;
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65;
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66;
  VMSTAT_PGINODESTEAL = 67;
  VMSTAT_SLABS_SCANNED = 68;
  VMSTAT_KSWAPD_INODESTEAL = 69;
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70;
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71;
  VMSTAT_PAGEOUTRUN = 72;
  VMSTAT_ALLOCSTALL = 73;
  VMSTAT_PGROTATED = 74;
  VMSTAT_DROP_PAGECACHE = 75;
  VMSTAT_DROP_SLAB = 76;
  VMSTAT_PGMIGRATE_SUCCESS = 77;
  VMSTAT_PGMIGRATE_FAIL = 78;
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79;
  VMSTAT_COMPACT_FREE_SCANNED = 80;
  VMSTAT_COMPACT_ISOLATED = 81;
  VMSTAT_COMPACT_STALL = 82;
  VMSTAT_COMPACT_FAIL = 83;
  VMSTAT_COMPACT_SUCCESS = 84;
  VMSTAT_COMPACT_DAEMON_WAKE = 85;
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86;
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87;
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88;
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89;
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90;
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91;
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92;
}
// End of protos/perfetto/common/sys_stats_counters.proto

// Begin of protos/perfetto/trace/android/android_log.proto

message AndroidLogPacket {
  message LogEvent {
    // The log buffer (e.g. MAIN, SYSTEM, RADIO) the event comes from.
    optional AndroidLogId log_id = 1;

    // PID (TGID), TID and UID of the task that emitted the event.
    optional int32 pid = 2;
    optional int32 tid = 3;
    optional int32 uid = 4;

    // Timestamp [ns]. The clock source is CLOCK_REALTIME, unlike many other
    // Perfetto trace events that instead use CLOCK_BOOTTIME. The trace
    // processor will take care of realigning clocks using the ClockSnapshot(s).
    optional uint64 timestamp = 5;

    // When log_id == LID_EVENTS, |tag| corresponds to the event name defined in
    // the second column of /system/etc/event-log-tags. For all other events,
    // |tag| is the app-specified argument passed to __android_log_write().
    optional string tag = 6;

    // Empty when log_id == LID_EVENTS.
    optional AndroidLogPriority prio = 7;

    // Empty when log_id == LID_EVENTS.
    optional string message = 8;

    message Arg {
      optional string name = 1;
      oneof value {
        int64 int_value = 2;
        float float_value = 3;
        string string_value = 4;
      }
    }
    // Only populated when log_id == LID_EVENTS.
    repeated Arg args = 9;
  }

  repeated LogEvent events = 1;

  // Stats are emitted only upon Flush() and are monotonic (i.e. they are
  // absolute counters since the beginning of the lifetime of the tracing
  // session and NOT relative to the previous Stats snapshot).
  message Stats {
    // Total number of log events seen, including errors and skipped entries
    // (num of events stored in the trace = total - failed - skipped).
    optional uint64 num_total = 1;

    // Parser failures.
    optional uint64 num_failed = 2;

    // Messages skipped due to filters.
    optional uint64 num_skipped = 3;
  }
  optional Stats stats = 2;
}

// End of protos/perfetto/trace/android/android_log.proto

// Begin of protos/perfetto/trace/clock_snapshot.proto

// A snapshot of clock readings to allow for trace alignment.
message ClockSnapshot {
  message Clock {
    enum Type {
      UNKNOWN = 0;
      REALTIME = 1;
      REALTIME_COARSE = 2;
      MONOTONIC = 3;
      MONOTONIC_COARSE = 4;
      MONOTONIC_RAW = 5;
      BOOTTIME = 6;
      PROCESS_CPUTIME = 7;
      THREAD_CPUTIME = 8;
    }
    optional Type type = 1;
    optional uint64 timestamp = 2;
  }
  repeated Clock clocks = 1;
}

// End of protos/perfetto/trace/clock_snapshot.proto

// Begin of protos/perfetto/trace/filesystem/inode_file_map.proto

// Represents the mapping between inode numbers in a block device and their path
// on the filesystem
message InodeFileMap {
  // Representation of Entry
  message Entry {
    optional uint64 inode_number = 1;

    // The path to the file, e.g. "etc/file.xml"
    // List of strings for multiple hardlinks
    repeated string paths = 2;

    // The file type
    enum Type {
      UNKNOWN = 0;
      FILE = 1;
      DIRECTORY = 2;
    }
    optional Type type = 3;
  }

  optional uint64 block_device_id = 1;

  // The mount points of the block device, e.g. ["system"].
  repeated string mount_points = 2;

  // The list of all the entries from the block device
  repeated Entry entries = 3;
}

// End of protos/perfetto/trace/filesystem/inode_file_map.proto

// Begin of protos/perfetto/trace/ftrace/binder.proto

message BinderTransactionFtraceEvent {
  optional int32 debug_id = 1;
  optional int32 target_node = 2;
  optional int32 to_proc = 3;
  optional int32 to_thread = 4;
  optional int32 reply = 5;
  optional uint32 code = 6;
  optional uint32 flags = 7;
}
message BinderTransactionReceivedFtraceEvent {
  optional int32 debug_id = 1;
}
message BinderSetPriorityFtraceEvent {
  optional int32 proc = 1;
  optional int32 thread = 2;
  optional uint32 old_prio = 3;
  optional uint32 new_prio = 4;
  optional uint32 desired_prio = 5;
}
message BinderLockFtraceEvent {
  optional string tag = 1;
}
message BinderLockedFtraceEvent {
  optional string tag = 1;
}
message BinderUnlockFtraceEvent {
  optional string tag = 1;
}
message BinderTransactionAllocBufFtraceEvent {
  optional uint64 data_size = 1;
  optional int32 debug_id = 2;
  optional uint64 offsets_size = 3;
}

// End of protos/perfetto/trace/ftrace/binder.proto

// Begin of protos/perfetto/trace/ftrace/block.proto

message BlockRqIssueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint32 bytes = 4;
  optional string rwbs = 5;
  optional string comm = 6;
  optional string cmd = 7;
}
message BlockBioBackmergeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioBounceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioCompleteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 error = 4;
  optional string rwbs = 5;
}
message BlockBioFrontmergeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioQueueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockBioRemapFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint64 old_dev = 4;
  optional uint64 old_sector = 5;
  optional string rwbs = 6;
}
message BlockDirtyBufferFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 size = 3;
}
message BlockGetrqFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockPlugFtraceEvent {
  optional string comm = 1;
}
message BlockRqAbortFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
}
message BlockRqCompleteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
}
message BlockRqInsertFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint32 bytes = 4;
  optional string rwbs = 5;
  optional string comm = 6;
  optional string cmd = 7;
}
message BlockRqRemapFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional uint64 old_dev = 4;
  optional uint64 old_sector = 5;
  optional uint32 nr_bios = 6;
  optional string rwbs = 7;
}
message BlockRqRequeueFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional int32 errors = 4;
  optional string rwbs = 5;
  optional string cmd = 6;
}
message BlockSleeprqFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint32 nr_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockSplitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 new_sector = 3;
  optional string rwbs = 4;
  optional string comm = 5;
}
message BlockTouchBufferFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 sector = 2;
  optional uint64 size = 3;
}
message BlockUnplugFtraceEvent {
  optional int32 nr_rq = 1;
  optional string comm = 2;
}

// End of protos/perfetto/trace/ftrace/block.proto

// Begin of protos/perfetto/trace/ftrace/clk.proto

message ClkEnableFtraceEvent {
  optional string name = 1;
}
message ClkDisableFtraceEvent {
  optional string name = 1;
}
message ClkSetRateFtraceEvent {
  optional string name = 1;
  optional uint64 rate = 2;
}

// End of protos/perfetto/trace/ftrace/clk.proto

// Begin of protos/perfetto/trace/ftrace/ext4.proto

message Ext4DaWriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4DaWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4SyncFileEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 parent = 3;
  optional int32 datasync = 4;
}
message Ext4SyncFileExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message Ext4AllocDaBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 data_blocks = 3;
  optional uint32 meta_blocks = 4;
}
message Ext4AllocateBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint32 len = 4;
  optional uint32 logical = 5;
  optional uint32 lleft = 6;
  optional uint32 lright = 7;
  optional uint64 goal = 8;
  optional uint64 pleft = 9;
  optional uint64 pright = 10;
  optional uint32 flags = 11;
}
message Ext4AllocateInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 dir = 3;
  optional uint32 mode = 4;
}
message Ext4BeginOrderedTruncateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 new_size = 3;
}
message Ext4CollapseRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
}
message Ext4DaReleaseSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 freed_blocks = 4;
  optional int32 reserved_data_blocks = 5;
  optional int32 reserved_meta_blocks = 6;
  optional int32 allocated_meta_blocks = 7;
  optional uint32 mode = 8;
}
message Ext4DaReserveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 reserved_data_blocks = 4;
  optional int32 reserved_meta_blocks = 5;
  optional uint32 mode = 6;
  optional int32 md_needed = 7;
}
message Ext4DaUpdateReserveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 i_blocks = 3;
  optional int32 used_blocks = 4;
  optional int32 reserved_data_blocks = 5;
  optional int32 reserved_meta_blocks = 6;
  optional int32 allocated_meta_blocks = 7;
  optional int32 quota_claim = 8;
  optional uint32 mode = 9;
}
message Ext4DaWritePagesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 first_page = 3;
  optional int64 nr_to_write = 4;
  optional int32 sync_mode = 5;
  optional uint64 b_blocknr = 6;
  optional uint32 b_size = 7;
  optional uint32 b_state = 8;
  optional int32 io_done = 9;
  optional int32 pages_written = 10;
}
message Ext4DaWritePagesExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4DirectIOEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint64 len = 4;
  optional int32 rw = 5;
}
message Ext4DirectIOExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint64 len = 4;
  optional int32 rw = 5;
  optional int32 ret = 6;
}
message Ext4DiscardBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 blk = 2;
  optional uint64 count = 3;
}
message Ext4DiscardPreallocationsFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
}
message Ext4DropInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 drop = 3;
}
message Ext4EsCacheExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint32 status = 6;
}
message Ext4EsFindDelayedExtentRangeEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
}
message Ext4EsFindDelayedExtentRangeExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
}
message Ext4EsInsertExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
}
message Ext4EsLookupExtentEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
}
message Ext4EsLookupExtentExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 pblk = 5;
  optional uint64 status = 6;
  optional int32 found = 7;
}
message Ext4EsRemoveExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 lblk = 3;
  optional int64 len = 4;
}
message Ext4EsShrinkFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_shrunk = 2;
  optional uint64 scan_time = 3;
  optional int32 nr_skipped = 4;
  optional int32 retried = 5;
}
message Ext4EsShrinkCountFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_to_scan = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EsShrinkScanEnterFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_to_scan = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EsShrinkScanExitFtraceEvent {
  optional uint64 dev = 1;
  optional int32 nr_shrunk = 2;
  optional int32 cache_cnt = 3;
}
message Ext4EvictInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 nlink = 3;
}
message Ext4ExtConvertToInitializedEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 m_lblk = 3;
  optional uint32 m_len = 4;
  optional uint32 u_lblk = 5;
  optional uint32 u_len = 6;
  optional uint64 u_pblk = 7;
}
message Ext4ExtConvertToInitializedFastpathFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 m_lblk = 3;
  optional uint32 m_len = 4;
  optional uint32 u_lblk = 5;
  optional uint32 u_len = 6;
  optional uint64 u_pblk = 7;
  optional uint32 i_lblk = 8;
  optional uint32 i_len = 9;
  optional uint64 i_pblk = 10;
}
message Ext4ExtHandleUnwrittenExtentsFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 flags = 3;
  optional uint32 lblk = 4;
  optional uint64 pblk = 5;
  optional uint32 len = 6;
  optional uint32 allocated = 7;
  optional uint64 newblk = 8;
}
message Ext4ExtInCacheFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional int32 ret = 4;
}
message Ext4ExtLoadExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
  optional uint32 lblk = 4;
}
message Ext4ExtMapBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4ExtMapBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 flags = 3;
  optional uint64 pblk = 4;
  optional uint32 lblk = 5;
  optional uint32 len = 6;
  optional uint32 mflags = 7;
  optional int32 ret = 8;
}
message Ext4ExtPutInCacheFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint64 start = 5;
}
message Ext4ExtRemoveSpaceFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 start = 3;
  optional uint32 end = 4;
  optional int32 depth = 5;
}
message Ext4ExtRemoveSpaceDoneFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 start = 3;
  optional uint32 end = 4;
  optional int32 depth = 5;
  optional int64 partial = 6;
  optional uint32 eh_entries = 7;
}
message Ext4ExtRmIdxFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
}
message Ext4ExtRmLeafFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 partial = 3;
  optional uint32 start = 4;
  optional uint32 ee_lblk = 5;
  optional uint64 ee_pblk = 6;
  optional int32 ee_len = 7;
}
message Ext4ExtShowExtentFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pblk = 3;
  optional uint32 lblk = 4;
  optional uint32 len = 5;
}
message Ext4FallocateEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
  optional int64 pos = 6;
}
message Ext4FallocateExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 blocks = 4;
  optional int32 ret = 5;
}
message Ext4FindDelallocRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 from = 3;
  optional uint32 to = 4;
  optional int32 reverse = 5;
  optional int32 found = 6;
  optional uint32 found_blk = 7;
}
message Ext4ForgetFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional int32 is_metadata = 4;
  optional uint32 mode = 5;
}
message Ext4FreeBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint64 count = 4;
  optional int32 flags = 5;
  optional uint32 mode = 6;
}
message Ext4FreeInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 uid = 3;
  optional uint32 gid = 4;
  optional uint64 blocks = 5;
  optional uint32 mode = 6;
}
message Ext4GetImpliedClusterAllocExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 flags = 2;
  optional uint32 lblk = 3;
  optional uint64 pblk = 4;
  optional uint32 len = 5;
  optional int32 ret = 6;
}
message Ext4GetReservedClusterAllocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
}
message Ext4IndMapBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 lblk = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4IndMapBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 flags = 3;
  optional uint64 pblk = 4;
  optional uint32 lblk = 5;
  optional uint32 len = 6;
  optional uint32 mflags = 7;
  optional int32 ret = 8;
}
message Ext4InsertRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
}
message Ext4InvalidatepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 offset = 4;
  optional uint32 length = 5;
}
message Ext4JournalStartFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ip = 2;
  optional int32 blocks = 3;
  optional int32 rsv_blocks = 4;
  optional int32 nblocks = 5;
}
message Ext4JournalStartReservedFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ip = 2;
  optional int32 blocks = 3;
}
message Ext4JournalledInvalidatepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 offset = 4;
  optional uint32 length = 5;
}
message Ext4JournalledWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4LoadInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
}
message Ext4LoadInodeBitmapFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MarkInodeDirtyFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 ip = 3;
}
message Ext4MbBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MbBuddyBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4MbDiscardPreallocationsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 needed = 2;
}
message Ext4MbNewGroupPaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pa_pstart = 3;
  optional uint64 pa_lstart = 4;
  optional uint32 pa_len = 5;
}
message Ext4MbNewInodePaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pa_pstart = 3;
  optional uint64 pa_lstart = 4;
  optional uint32 pa_len = 5;
}
message Ext4MbReleaseGroupPaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 pa_pstart = 2;
  optional uint32 pa_len = 3;
}
message Ext4MbReleaseInodePaFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 block = 3;
  optional uint32 count = 4;
}
message Ext4MballocAllocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 orig_logical = 3;
  optional int32 orig_start = 4;
  optional uint32 orig_group = 5;
  optional int32 orig_len = 6;
  optional uint32 goal_logical = 7;
  optional int32 goal_start = 8;
  optional uint32 goal_group = 9;
  optional int32 goal_len = 10;
  optional uint32 result_logical = 11;
  optional int32 result_start = 12;
  optional uint32 result_group = 13;
  optional int32 result_len = 14;
  optional uint32 found = 15;
  optional uint32 groups = 16;
  optional uint32 buddy = 17;
  optional uint32 flags = 18;
  optional uint32 tail = 19;
  optional uint32 cr = 20;
}
message Ext4MballocDiscardFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 result_start = 3;
  optional uint32 result_group = 4;
  optional int32 result_len = 5;
}
message Ext4MballocFreeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 result_start = 3;
  optional uint32 result_group = 4;
  optional int32 result_len = 5;
}
message Ext4MballocPreallocFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 orig_logical = 3;
  optional int32 orig_start = 4;
  optional uint32 orig_group = 5;
  optional int32 orig_len = 6;
  optional uint32 result_logical = 7;
  optional int32 result_start = 8;
  optional uint32 result_group = 9;
  optional int32 result_len = 10;
}
message Ext4OtherInodeUpdateTimeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 orig_ino = 3;
  optional uint32 uid = 4;
  optional uint32 gid = 5;
  optional uint32 mode = 6;
}
message Ext4PunchHoleFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
}
message Ext4ReadBlockBitmapLoadFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 group = 2;
}
message Ext4ReadpageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4ReleasepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4RemoveBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 from = 3;
  optional uint32 to = 4;
  optional int64 partial = 5;
  optional uint64 ee_pblk = 6;
  optional uint32 ee_lblk = 7;
  optional uint32 ee_len = 8;
}
message Ext4RequestBlocksFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 len = 3;
  optional uint32 logical = 4;
  optional uint32 lleft = 5;
  optional uint32 lright = 6;
  optional uint64 goal = 7;
  optional uint64 pleft = 8;
  optional uint64 pright = 9;
  optional uint32 flags = 10;
}
message Ext4RequestInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 dir = 2;
  optional uint32 mode = 3;
}
message Ext4SyncFsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 wait = 2;
}
message Ext4TrimAllFreeFtraceEvent {
  optional int32 dev_major = 1;
  optional int32 dev_minor = 2;
  optional uint32 group = 3;
  optional int32 start = 4;
  optional int32 len = 5;
}
message Ext4TrimExtentFtraceEvent {
  optional int32 dev_major = 1;
  optional int32 dev_minor = 2;
  optional uint32 group = 3;
  optional int32 start = 4;
  optional int32 len = 5;
}
message Ext4TruncateEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 blocks = 3;
}
message Ext4TruncateExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 blocks = 3;
}
message Ext4UnlinkEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 parent = 3;
  optional int64 size = 4;
}
message Ext4UnlinkExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message Ext4WriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message Ext4WriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}
message Ext4WritepageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
}
message Ext4WritepagesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 nr_to_write = 3;
  optional int64 pages_skipped = 4;
  optional int64 range_start = 5;
  optional int64 range_end = 6;
  optional uint64 writeback_index = 7;
  optional int32 sync_mode = 8;
  optional uint32 for_kupdate = 9;
  optional uint32 range_cyclic = 10;
}
message Ext4WritepagesResultFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
  optional int32 pages_written = 4;
  optional int64 pages_skipped = 5;
  optional uint64 writeback_index = 6;
  optional int32 sync_mode = 7;
}
message Ext4ZeroRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 offset = 3;
  optional int64 len = 4;
  optional int32 mode = 5;
}

// End of protos/perfetto/trace/ftrace/ext4.proto

// Begin of protos/perfetto/trace/ftrace/f2fs.proto

message F2fsDoSubmitBioFtraceEvent {
  optional uint64 dev = 1;
  optional int32 btype = 2;
  optional uint32 sync = 3;
  optional uint64 sector = 4;
  optional uint32 size = 5;
}
message F2fsEvictInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsFallocateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 mode = 3;
  optional int64 offset = 4;
  optional int64 len = 5;
  optional int64 size = 6;
  optional uint64 blocks = 7;
  optional int32 ret = 8;
}
message F2fsGetDataBlockFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 iblock = 3;
  optional uint64 bh_start = 4;
  optional uint64 bh_size = 5;
  optional int32 ret = 6;
}
message F2fsGetVictimFtraceEvent {
  optional uint64 dev = 1;
  optional int32 type = 2;
  optional int32 gc_type = 3;
  optional int32 alloc_mode = 4;
  optional int32 gc_mode = 5;
  optional uint32 victim = 6;
  optional uint32 ofs_unit = 7;
  optional uint32 pre_victim = 8;
  optional uint32 prefree = 9;
  optional uint32 free = 10;
}
message F2fsIgetFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsIgetExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsNewInodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsReadpageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 index = 3;
  optional uint64 blkaddr = 4;
  optional int32 type = 5;
}
message F2fsReserveNewBlockFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 nid = 2;
  optional uint32 ofs_in_node = 3;
}
message F2fsSetPageDirtyFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional int32 dir = 4;
  optional uint64 index = 5;
  optional int32 dirty = 6;
}
message F2fsSubmitWritePageFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional uint64 index = 4;
  optional uint32 block = 5;
}
message F2fsSyncFileEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsSyncFileExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 need_cp = 3;
  optional int32 datasync = 4;
  optional int32 ret = 5;
}
message F2fsSyncFsFtraceEvent {
  optional uint64 dev = 1;
  optional int32 dirty = 2;
  optional int32 wait = 3;
}
message F2fsTruncateFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint64 pino = 3;
  optional uint32 mode = 4;
  optional int64 size = 5;
  optional uint32 nlink = 6;
  optional uint64 blocks = 7;
  optional uint32 advise = 8;
}
message F2fsTruncateBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional uint64 from = 5;
}
message F2fsTruncateBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncateDataBlocksRangeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 ofs = 4;
  optional int32 free = 5;
}
message F2fsTruncateInodeBlocksEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional uint64 from = 5;
}
message F2fsTruncateInodeBlocksExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncateNodeFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 blk_addr = 4;
}
message F2fsTruncateNodesEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional uint32 blk_addr = 4;
}
message F2fsTruncateNodesExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsTruncatePartialNodesFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional uint32 nid = 3;
  optional int32 depth = 4;
  optional int32 err = 5;
}
message F2fsUnlinkEnterFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 size = 3;
  optional uint64 blocks = 4;
  optional string name = 5;
}
message F2fsUnlinkExitFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 ret = 3;
}
message F2fsVmPageMkwriteFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int32 type = 3;
  optional int32 dir = 4;
  optional uint64 index = 5;
  optional int32 dirty = 6;
}
message F2fsWriteBeginFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 flags = 5;
}
message F2fsWriteCheckpointFtraceEvent {
  optional uint64 dev = 1;
  optional uint32 is_umount = 2;
  optional string msg = 3;
}
message F2fsWriteEndFtraceEvent {
  optional uint64 dev = 1;
  optional uint64 ino = 2;
  optional int64 pos = 3;
  optional uint32 len = 4;
  optional uint32 copied = 5;
}

// End of protos/perfetto/trace/ftrace/f2fs.proto

// Begin of protos/perfetto/trace/ftrace/filemap.proto

message MmFilemapAddToPageCacheFtraceEvent {
  optional uint64 pfn = 1;
  optional uint64 i_ino = 2;
  optional uint64 index = 3;
  optional uint64 s_dev = 4;
  optional uint64 page = 5;
}
message MmFilemapDeleteFromPageCacheFtraceEvent {
  optional uint64 pfn = 1;
  optional uint64 i_ino = 2;
  optional uint64 index = 3;
  optional uint64 s_dev = 4;
  optional uint64 page = 5;
}

// End of protos/perfetto/trace/ftrace/filemap.proto

// Begin of protos/perfetto/trace/ftrace/ftrace.proto

message PrintFtraceEvent {
  optional uint64 ip = 1;
  optional string buf = 2;
}

// End of protos/perfetto/trace/ftrace/ftrace.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_event.proto

message FtraceEvent {
  // Nanoseconds since an epoch.
  // Epoch is configurable by writing into trace_clock.
  // By default this timestamp is CPU local.
  // TODO: Figure out a story for reconciling the various clocks.
  optional uint64 timestamp = 1;

  // Kernel pid (do not confuse with userspace pid aka tgid)
  optional uint32 pid = 2;

  oneof event {
    PrintFtraceEvent print = 3;
    SchedSwitchFtraceEvent sched_switch = 4;
    // removed field with id 5;
    // removed field with id 6;
    // removed field with id 7;
    // removed field with id 8;
    // removed field with id 9;
    // removed field with id 10;
    CpuFrequencyFtraceEvent cpu_frequency = 11;
    CpuFrequencyLimitsFtraceEvent cpu_frequency_limits = 12;
    CpuIdleFtraceEvent cpu_idle = 13;
    ClockEnableFtraceEvent clock_enable = 14;
    ClockDisableFtraceEvent clock_disable = 15;
    ClockSetRateFtraceEvent clock_set_rate = 16;
    SchedWakeupFtraceEvent sched_wakeup = 17;
    SchedBlockedReasonFtraceEvent sched_blocked_reason = 18;
    SchedCpuHotplugFtraceEvent sched_cpu_hotplug = 19;
    SchedWakingFtraceEvent sched_waking = 20;
    // removed field with id 21
    // removed field with id 22
    // removed field with id 23
    // removed field with id 24
    // removed field with id 25
    // removed field with id 26
    // removed field with id 27
    // removed field with id 28
    // removed field with id 29
    // removed field with id 30
    // removed field with id 31
    // removed field with id 32
    // removed field with id 33
    // removed field with id 34
    LowmemoryKillFtraceEvent lowmemory_kill = 35;
    // removed field with id 36
    // removed field with id 37
    // removed field with id 38
    // removed field with id 39
    // removed field with id 40
    Ext4DaWriteBeginFtraceEvent ext4_da_write_begin = 41;
    Ext4DaWriteEndFtraceEvent ext4_da_write_end = 42;
    Ext4SyncFileEnterFtraceEvent ext4_sync_file_enter = 43;
    Ext4SyncFileExitFtraceEvent ext4_sync_file_exit = 44;
    BlockRqIssueFtraceEvent block_rq_issue = 45;
    MmVmscanDirectReclaimBeginFtraceEvent mm_vmscan_direct_reclaim_begin = 46;
    MmVmscanDirectReclaimEndFtraceEvent mm_vmscan_direct_reclaim_end = 47;
    MmVmscanKswapdWakeFtraceEvent mm_vmscan_kswapd_wake = 48;
    MmVmscanKswapdSleepFtraceEvent mm_vmscan_kswapd_sleep = 49;
    BinderTransactionFtraceEvent binder_transaction = 50;
    BinderTransactionReceivedFtraceEvent binder_transaction_received = 51;
    BinderSetPriorityFtraceEvent binder_set_priority = 52;
    BinderLockFtraceEvent binder_lock = 53;
    BinderLockedFtraceEvent binder_locked = 54;
    BinderUnlockFtraceEvent binder_unlock = 55;
    // removed field with id 56
    // removed field with id 57
    // removed field with id 58
    // removed field with id 59
    // removed field with id 60
    // removed field with id 61
    // removed field with id 62
    // removed field with id 63
    // removed field with id 64
    // removed field with id 65
    // removed field with id 66
    // removed field with id 67
    // removed field with id 68
    // removed field with id 69
    // removed field with id 70
    // removed field with id 71
    // removed field with id 72
    // removed field with id 73
    // removed field with id 74
    // removed field with id 75
    // removed field with id 76
    // removed field with id 77
    // removed field with id 78
    // removed field with id 79
    // removed field with id 80
    // removed field with id 81
    // removed field with id 82
    // removed field with id 83
    // removed field with id 84
    // removed field with id 85
    // removed field with id 86
    // removed field with id 87
    // removed field with id 88
    // removed field with id 89
    // removed field with id 90
    // removed field with id 91
    // removed field with id 92
    // removed field with id 93
    // removed field with id 94
    // removed field with id 95
    // removed field with id 96
    MmFilemapAddToPageCacheFtraceEvent mm_filemap_add_to_page_cache = 97;
    MmFilemapDeleteFromPageCacheFtraceEvent mm_filemap_delete_from_page_cache =
        98;
    // removed field with id 99
    // removed field with id 100
    // removed field with id 101
    // removed field with id 102
    // removed field with id 103
    // removed field with id 104
    // removed field with id 105
    // removed field with id 106
    // removed field with id 107
    // removed field with id 108
    // removed field with id 109
    // removed field with id 110
    // removed field with id 111
    // removed field with id 112
    SuspendResumeFtraceEvent suspend_resume = 113;
    SchedWakeupNewFtraceEvent sched_wakeup_new = 114;
    BlockBioBackmergeFtraceEvent block_bio_backmerge = 115;
    BlockBioBounceFtraceEvent block_bio_bounce = 116;
    BlockBioCompleteFtraceEvent block_bio_complete = 117;
    BlockBioFrontmergeFtraceEvent block_bio_frontmerge = 118;
    BlockBioQueueFtraceEvent block_bio_queue = 119;
    BlockBioRemapFtraceEvent block_bio_remap = 120;
    BlockDirtyBufferFtraceEvent block_dirty_buffer = 121;
    BlockGetrqFtraceEvent block_getrq = 122;
    BlockPlugFtraceEvent block_plug = 123;
    BlockRqAbortFtraceEvent block_rq_abort = 124;
    BlockRqCompleteFtraceEvent block_rq_complete = 125;
    BlockRqInsertFtraceEvent block_rq_insert = 126;
    // removed field with id 127;
    BlockRqRemapFtraceEvent block_rq_remap = 128;
    BlockRqRequeueFtraceEvent block_rq_requeue = 129;
    BlockSleeprqFtraceEvent block_sleeprq = 130;
    BlockSplitFtraceEvent block_split = 131;
    BlockTouchBufferFtraceEvent block_touch_buffer = 132;
    BlockUnplugFtraceEvent block_unplug = 133;
    Ext4AllocDaBlocksFtraceEvent ext4_alloc_da_blocks = 134;
    Ext4AllocateBlocksFtraceEvent ext4_allocate_blocks = 135;
    Ext4AllocateInodeFtraceEvent ext4_allocate_inode = 136;
    Ext4BeginOrderedTruncateFtraceEvent ext4_begin_ordered_truncate = 137;
    Ext4CollapseRangeFtraceEvent ext4_collapse_range = 138;
    Ext4DaReleaseSpaceFtraceEvent ext4_da_release_space = 139;
    Ext4DaReserveSpaceFtraceEvent ext4_da_reserve_space = 140;
    Ext4DaUpdateReserveSpaceFtraceEvent ext4_da_update_reserve_space = 141;
    Ext4DaWritePagesFtraceEvent ext4_da_write_pages = 142;
    Ext4DaWritePagesExtentFtraceEvent ext4_da_write_pages_extent = 143;
    Ext4DirectIOEnterFtraceEvent ext4_direct_IO_enter = 144;
    Ext4DirectIOExitFtraceEvent ext4_direct_IO_exit = 145;
    Ext4DiscardBlocksFtraceEvent ext4_discard_blocks = 146;
    Ext4DiscardPreallocationsFtraceEvent ext4_discard_preallocations = 147;
    Ext4DropInodeFtraceEvent ext4_drop_inode = 148;
    Ext4EsCacheExtentFtraceEvent ext4_es_cache_extent = 149;
    Ext4EsFindDelayedExtentRangeEnterFtraceEvent
        ext4_es_find_delayed_extent_range_enter = 150;
    Ext4EsFindDelayedExtentRangeExitFtraceEvent
        ext4_es_find_delayed_extent_range_exit = 151;
    Ext4EsInsertExtentFtraceEvent ext4_es_insert_extent = 152;
    Ext4EsLookupExtentEnterFtraceEvent ext4_es_lookup_extent_enter = 153;
    Ext4EsLookupExtentExitFtraceEvent ext4_es_lookup_extent_exit = 154;
    Ext4EsRemoveExtentFtraceEvent ext4_es_remove_extent = 155;
    Ext4EsShrinkFtraceEvent ext4_es_shrink = 156;
    Ext4EsShrinkCountFtraceEvent ext4_es_shrink_count = 157;
    Ext4EsShrinkScanEnterFtraceEvent ext4_es_shrink_scan_enter = 158;
    Ext4EsShrinkScanExitFtraceEvent ext4_es_shrink_scan_exit = 159;
    Ext4EvictInodeFtraceEvent ext4_evict_inode = 160;
    Ext4ExtConvertToInitializedEnterFtraceEvent
        ext4_ext_convert_to_initialized_enter = 161;
    Ext4ExtConvertToInitializedFastpathFtraceEvent
        ext4_ext_convert_to_initialized_fastpath = 162;
    Ext4ExtHandleUnwrittenExtentsFtraceEvent ext4_ext_handle_unwritten_extents =
        163;
    Ext4ExtInCacheFtraceEvent ext4_ext_in_cache = 164;
    Ext4ExtLoadExtentFtraceEvent ext4_ext_load_extent = 165;
    Ext4ExtMapBlocksEnterFtraceEvent ext4_ext_map_blocks_enter = 166;
    Ext4ExtMapBlocksExitFtraceEvent ext4_ext_map_blocks_exit = 167;
    Ext4ExtPutInCacheFtraceEvent ext4_ext_put_in_cache = 168;
    Ext4ExtRemoveSpaceFtraceEvent ext4_ext_remove_space = 169;
    Ext4ExtRemoveSpaceDoneFtraceEvent ext4_ext_remove_space_done = 170;
    Ext4ExtRmIdxFtraceEvent ext4_ext_rm_idx = 171;
    Ext4ExtRmLeafFtraceEvent ext4_ext_rm_leaf = 172;
    Ext4ExtShowExtentFtraceEvent ext4_ext_show_extent = 173;
    Ext4FallocateEnterFtraceEvent ext4_fallocate_enter = 174;
    Ext4FallocateExitFtraceEvent ext4_fallocate_exit = 175;
    Ext4FindDelallocRangeFtraceEvent ext4_find_delalloc_range = 176;
    Ext4ForgetFtraceEvent ext4_forget = 177;
    Ext4FreeBlocksFtraceEvent ext4_free_blocks = 178;
    Ext4FreeInodeFtraceEvent ext4_free_inode = 179;
    Ext4GetImpliedClusterAllocExitFtraceEvent
        ext4_get_implied_cluster_alloc_exit = 180;
    Ext4GetReservedClusterAllocFtraceEvent ext4_get_reserved_cluster_alloc =
        181;
    Ext4IndMapBlocksEnterFtraceEvent ext4_ind_map_blocks_enter = 182;
    Ext4IndMapBlocksExitFtraceEvent ext4_ind_map_blocks_exit = 183;
    Ext4InsertRangeFtraceEvent ext4_insert_range = 184;
    Ext4InvalidatepageFtraceEvent ext4_invalidatepage = 185;
    Ext4JournalStartFtraceEvent ext4_journal_start = 186;
    Ext4JournalStartReservedFtraceEvent ext4_journal_start_reserved = 187;
    Ext4JournalledInvalidatepageFtraceEvent ext4_journalled_invalidatepage =
        188;
    Ext4JournalledWriteEndFtraceEvent ext4_journalled_write_end = 189;
    Ext4LoadInodeFtraceEvent ext4_load_inode = 190;
    Ext4LoadInodeBitmapFtraceEvent ext4_load_inode_bitmap = 191;
    Ext4MarkInodeDirtyFtraceEvent ext4_mark_inode_dirty = 192;
    Ext4MbBitmapLoadFtraceEvent ext4_mb_bitmap_load = 193;
    Ext4MbBuddyBitmapLoadFtraceEvent ext4_mb_buddy_bitmap_load = 194;
    Ext4MbDiscardPreallocationsFtraceEvent ext4_mb_discard_preallocations = 195;
    Ext4MbNewGroupPaFtraceEvent ext4_mb_new_group_pa = 196;
    Ext4MbNewInodePaFtraceEvent ext4_mb_new_inode_pa = 197;
    Ext4MbReleaseGroupPaFtraceEvent ext4_mb_release_group_pa = 198;
    Ext4MbReleaseInodePaFtraceEvent ext4_mb_release_inode_pa = 199;
    Ext4MballocAllocFtraceEvent ext4_mballoc_alloc = 200;
    Ext4MballocDiscardFtraceEvent ext4_mballoc_discard = 201;
    Ext4MballocFreeFtraceEvent ext4_mballoc_free = 202;
    Ext4MballocPreallocFtraceEvent ext4_mballoc_prealloc = 203;
    Ext4OtherInodeUpdateTimeFtraceEvent ext4_other_inode_update_time = 204;
    Ext4PunchHoleFtraceEvent ext4_punch_hole = 205;
    Ext4ReadBlockBitmapLoadFtraceEvent ext4_read_block_bitmap_load = 206;
    Ext4ReadpageFtraceEvent ext4_readpage = 207;
    Ext4ReleasepageFtraceEvent ext4_releasepage = 208;
    Ext4RemoveBlocksFtraceEvent ext4_remove_blocks = 209;
    Ext4RequestBlocksFtraceEvent ext4_request_blocks = 210;
    Ext4RequestInodeFtraceEvent ext4_request_inode = 211;
    Ext4SyncFsFtraceEvent ext4_sync_fs = 212;
    Ext4TrimAllFreeFtraceEvent ext4_trim_all_free = 213;
    Ext4TrimExtentFtraceEvent ext4_trim_extent = 214;
    Ext4TruncateEnterFtraceEvent ext4_truncate_enter = 215;
    Ext4TruncateExitFtraceEvent ext4_truncate_exit = 216;
    Ext4UnlinkEnterFtraceEvent ext4_unlink_enter = 217;
    Ext4UnlinkExitFtraceEvent ext4_unlink_exit = 218;
    Ext4WriteBeginFtraceEvent ext4_write_begin = 219;
    // removed field with id 220;
    // removed field with id 221;
    // removed field with id 222;
    // removed field with id 223;
    // removed field with id 224;
    // removed field with id 225;
    // removed field with id 226;
    // removed field with id 227;
    // removed field with id 228;
    // removed field with id 229;
    Ext4WriteEndFtraceEvent ext4_write_end = 230;
    Ext4WritepageFtraceEvent ext4_writepage = 231;
    Ext4WritepagesFtraceEvent ext4_writepages = 232;
    Ext4WritepagesResultFtraceEvent ext4_writepages_result = 233;
    Ext4ZeroRangeFtraceEvent ext4_zero_range = 234;
    TaskNewtaskFtraceEvent task_newtask = 235;
    TaskRenameFtraceEvent task_rename = 236;
    SchedProcessExecFtraceEvent sched_process_exec = 237;
    SchedProcessExitFtraceEvent sched_process_exit = 238;
    SchedProcessForkFtraceEvent sched_process_fork = 239;
    SchedProcessFreeFtraceEvent sched_process_free = 240;
    SchedProcessHangFtraceEvent sched_process_hang = 241;
    SchedProcessWaitFtraceEvent sched_process_wait = 242;
    F2fsDoSubmitBioFtraceEvent f2fs_do_submit_bio = 243;
    F2fsEvictInodeFtraceEvent f2fs_evict_inode = 244;
    F2fsFallocateFtraceEvent f2fs_fallocate = 245;
    F2fsGetDataBlockFtraceEvent f2fs_get_data_block = 246;
    F2fsGetVictimFtraceEvent f2fs_get_victim = 247;
    F2fsIgetFtraceEvent f2fs_iget = 248;
    F2fsIgetExitFtraceEvent f2fs_iget_exit = 249;
    F2fsNewInodeFtraceEvent f2fs_new_inode = 250;
    F2fsReadpageFtraceEvent f2fs_readpage = 251;
    F2fsReserveNewBlockFtraceEvent f2fs_reserve_new_block = 252;
    F2fsSetPageDirtyFtraceEvent f2fs_set_page_dirty = 253;
    F2fsSubmitWritePageFtraceEvent f2fs_submit_write_page = 254;
    F2fsSyncFileEnterFtraceEvent f2fs_sync_file_enter = 255;
    F2fsSyncFileExitFtraceEvent f2fs_sync_file_exit = 256;
    F2fsSyncFsFtraceEvent f2fs_sync_fs = 257;
    F2fsTruncateFtraceEvent f2fs_truncate = 258;
    F2fsTruncateBlocksEnterFtraceEvent f2fs_truncate_blocks_enter = 259;
    F2fsTruncateBlocksExitFtraceEvent f2fs_truncate_blocks_exit = 260;
    F2fsTruncateDataBlocksRangeFtraceEvent f2fs_truncate_data_blocks_range =
        261;
    F2fsTruncateInodeBlocksEnterFtraceEvent f2fs_truncate_inode_blocks_enter =
        262;
    F2fsTruncateInodeBlocksExitFtraceEvent f2fs_truncate_inode_blocks_exit =
        263;
    F2fsTruncateNodeFtraceEvent f2fs_truncate_node = 264;
    F2fsTruncateNodesEnterFtraceEvent f2fs_truncate_nodes_enter = 265;
    F2fsTruncateNodesExitFtraceEvent f2fs_truncate_nodes_exit = 266;
    F2fsTruncatePartialNodesFtraceEvent f2fs_truncate_partial_nodes = 267;
    F2fsUnlinkEnterFtraceEvent f2fs_unlink_enter = 268;
    F2fsUnlinkExitFtraceEvent f2fs_unlink_exit = 269;
    F2fsVmPageMkwriteFtraceEvent f2fs_vm_page_mkwrite = 270;
    F2fsWriteBeginFtraceEvent f2fs_write_begin = 271;
    F2fsWriteCheckpointFtraceEvent f2fs_write_checkpoint = 272;
    F2fsWriteEndFtraceEvent f2fs_write_end = 273;
    AllocPagesIommuEndFtraceEvent alloc_pages_iommu_end = 274;
    AllocPagesIommuFailFtraceEvent alloc_pages_iommu_fail = 275;
    AllocPagesIommuStartFtraceEvent alloc_pages_iommu_start = 276;
    AllocPagesSysEndFtraceEvent alloc_pages_sys_end = 277;
    AllocPagesSysFailFtraceEvent alloc_pages_sys_fail = 278;
    AllocPagesSysStartFtraceEvent alloc_pages_sys_start = 279;
    DmaAllocContiguousRetryFtraceEvent dma_alloc_contiguous_retry = 280;
    IommuMapRangeFtraceEvent iommu_map_range = 281;
    IommuSecPtblMapRangeEndFtraceEvent iommu_sec_ptbl_map_range_end = 282;
    IommuSecPtblMapRangeStartFtraceEvent iommu_sec_ptbl_map_range_start = 283;
    IonAllocBufferEndFtraceEvent ion_alloc_buffer_end = 284;
    IonAllocBufferFailFtraceEvent ion_alloc_buffer_fail = 285;
    IonAllocBufferFallbackFtraceEvent ion_alloc_buffer_fallback = 286;
    IonAllocBufferStartFtraceEvent ion_alloc_buffer_start = 287;
    IonCpAllocRetryFtraceEvent ion_cp_alloc_retry = 288;
    IonCpSecureBufferEndFtraceEvent ion_cp_secure_buffer_end = 289;
    IonCpSecureBufferStartFtraceEvent ion_cp_secure_buffer_start = 290;
    IonPrefetchingFtraceEvent ion_prefetching = 291;
    IonSecureCmaAddToPoolEndFtraceEvent ion_secure_cma_add_to_pool_end = 292;
    IonSecureCmaAddToPoolStartFtraceEvent ion_secure_cma_add_to_pool_start =
        293;
    IonSecureCmaAllocateEndFtraceEvent ion_secure_cma_allocate_end = 294;
    IonSecureCmaAllocateStartFtraceEvent ion_secure_cma_allocate_start = 295;
    IonSecureCmaShrinkPoolEndFtraceEvent ion_secure_cma_shrink_pool_end = 296;
    IonSecureCmaShrinkPoolStartFtraceEvent ion_secure_cma_shrink_pool_start =
        297;
    KfreeFtraceEvent kfree = 298;
    KmallocFtraceEvent kmalloc = 299;
    KmallocNodeFtraceEvent kmalloc_node = 300;
    KmemCacheAllocFtraceEvent kmem_cache_alloc = 301;
    KmemCacheAllocNodeFtraceEvent kmem_cache_alloc_node = 302;
    KmemCacheFreeFtraceEvent kmem_cache_free = 303;
    MigratePagesEndFtraceEvent migrate_pages_end = 304;
    MigratePagesStartFtraceEvent migrate_pages_start = 305;
    MigrateRetryFtraceEvent migrate_retry = 306;
    MmPageAllocFtraceEvent mm_page_alloc = 307;
    MmPageAllocExtfragFtraceEvent mm_page_alloc_extfrag = 308;
    MmPageAllocZoneLockedFtraceEvent mm_page_alloc_zone_locked = 309;
    MmPageFreeFtraceEvent mm_page_free = 310;
    MmPageFreeBatchedFtraceEvent mm_page_free_batched = 311;
    MmPagePcpuDrainFtraceEvent mm_page_pcpu_drain = 312;
    RssStatFtraceEvent rss_stat = 313;
    IonHeapShrinkFtraceEvent ion_heap_shrink = 314;
    IonHeapGrowFtraceEvent ion_heap_grow = 315;
    // removed field with id 316
    // removed field with id 317
    // removed field with id 318
    // removed field with id 319
    ClkEnableFtraceEvent clk_enable = 320;
    ClkDisableFtraceEvent clk_disable = 321;
    ClkSetRateFtraceEvent clk_set_rate = 322;
    BinderTransactionAllocBufFtraceEvent binder_transaction_alloc_buf = 323;
    SignalDeliverFtraceEvent signal_deliver = 324;
    SignalGenerateFtraceEvent signal_generate = 325;
    // removed field with id 326
    GenericFtraceEvent generic = 327;
    MmEventRecordFtraceEvent mm_event_record = 328;
    SysEnterFtraceEvent sys_enter = 329;
    SysExitFtraceEvent sys_exit = 330;
  }
}

// End of protos/perfetto/trace/ftrace/ftrace_event.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_event_bundle.proto

message FtraceEventBundle {
  optional uint32 cpu = 1;
  repeated FtraceEvent event = 2;
  // Total of all overwrite fields from the headers of all kernel
  // ftrace pages we parsed into this FtraceEventBundle. Zero if
  // no overwriting occurred, a number larger than zero if some overwriting
  // occurred.
  optional uint32 overwrite_count = 3;
}

// End of protos/perfetto/trace/ftrace/ftrace_event_bundle.proto

// Begin of protos/perfetto/trace/ftrace/ftrace_stats.proto

// Per-CPU stats for the ftrace data source gathered from the kernel from
// /sys/kernel/debug/tracing/per_cpu/cpuX/stats.
message FtraceCpuStats {
  // CPU index.
  optional uint64 cpu = 1;

  // Number of entries still in the kernel buffer. Ideally this should be close
  // to zero, as events are consumed regularly and moved into the userspace
  // buffers (or file).
  optional uint64 entries = 2;

  // Number of events lost in kernel buffers due to overwriting of old events
  // before userspace had a chance to drain them.
  optional uint64 overrun = 3;

  // This should always be zero. If not the buffer size is way too small or
  // something went wrong with the tracer.
  optional uint64 commit_overrun = 4;

  // Bytes actually read (not overwritten).
  optional uint64 bytes_read = 5;

  // The timestamp for the oldest event still in the ring buffer.
  optional double oldest_event_ts = 6;

  // The current timestamp.
  optional double now_ts = 7;

  // If the kernel buffer has overwrite mode disabled, this will show the number
  // of new events that were lost because the buffer was full. This is similar
  // to |overrun| but only for the overwrite=false case.
  optional uint64 dropped_events = 8;

  // The number of events read.
  optional uint64 read_events = 9;
}

// Ftrace stats for all CPUs.
message FtraceStats {
  enum Phase {
    UNSPECIFIED = 0;
    START_OF_TRACE = 1;
    END_OF_TRACE = 2;
  }

  // Tells when stats were sampled. There should be one sample at the beginning
  // of the trace and one sample at the end.
  optional Phase phase = 1;

  // Per-CPU stats (one entry for each CPU).
  repeated FtraceCpuStats cpu_stats = 2;
}

// End of protos/perfetto/trace/ftrace/ftrace_stats.proto

// Begin of protos/perfetto/trace/ftrace/generic.proto

// This generic proto is used to output events in the trace
// when a specific proto for that event does not exist.
message GenericFtraceEvent {
  message Field {
    optional string name = 1;
    oneof value {
      string str_value = 3;
      int64 int_value = 4;
      uint64 uint_value = 5;
    }
  }

  optional string event_name = 1;
  repeated Field field = 2;
}

// End of protos/perfetto/trace/ftrace/generic.proto

// Begin of protos/perfetto/trace/ftrace/kmem.proto

message AllocPagesIommuEndFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesIommuFailFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesIommuStartFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysEndFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysFailFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message AllocPagesSysStartFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional uint32 order = 2;
}
message DmaAllocContiguousRetryFtraceEvent {
  optional int32 tries = 1;
}
message IommuMapRangeFtraceEvent {
  optional uint64 chunk_size = 1;
  optional uint64 len = 2;
  optional uint64 pa = 3;
  optional uint64 va = 4;
}
message IommuSecPtblMapRangeEndFtraceEvent {
  optional uint64 len = 1;
  optional int32 num = 2;
  optional uint32 pa = 3;
  optional int32 sec_id = 4;
  optional uint64 va = 5;
}
message IommuSecPtblMapRangeStartFtraceEvent {
  optional uint64 len = 1;
  optional int32 num = 2;
  optional uint32 pa = 3;
  optional int32 sec_id = 4;
  optional uint64 va = 5;
}
message IonAllocBufferEndFtraceEvent {
  optional string client_name = 1;
  optional uint32 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
  optional uint32 mask = 5;
}
message IonAllocBufferFailFtraceEvent {
  optional string client_name = 1;
  optional int64 error = 2;
  optional uint32 flags = 3;
  optional string heap_name = 4;
  optional uint64 len = 5;
  optional uint32 mask = 6;
}
message IonAllocBufferFallbackFtraceEvent {
  optional string client_name = 1;
  optional int64 error = 2;
  optional uint32 flags = 3;
  optional string heap_name = 4;
  optional uint64 len = 5;
  optional uint32 mask = 6;
}
message IonAllocBufferStartFtraceEvent {
  optional string client_name = 1;
  optional uint32 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
  optional uint32 mask = 5;
}
message IonCpAllocRetryFtraceEvent {
  optional int32 tries = 1;
}
message IonCpSecureBufferEndFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonCpSecureBufferStartFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonPrefetchingFtraceEvent {
  optional uint64 len = 1;
}
message IonSecureCmaAddToPoolEndFtraceEvent {
  optional uint32 is_prefetch = 1;
  optional uint64 len = 2;
  optional int32 pool_total = 3;
}
message IonSecureCmaAddToPoolStartFtraceEvent {
  optional uint32 is_prefetch = 1;
  optional uint64 len = 2;
  optional int32 pool_total = 3;
}
message IonSecureCmaAllocateEndFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonSecureCmaAllocateStartFtraceEvent {
  optional uint64 align = 1;
  optional uint64 flags = 2;
  optional string heap_name = 3;
  optional uint64 len = 4;
}
message IonSecureCmaShrinkPoolEndFtraceEvent {
  optional uint64 drained_size = 1;
  optional uint64 skipped_size = 2;
}
message IonSecureCmaShrinkPoolStartFtraceEvent {
  optional uint64 drained_size = 1;
  optional uint64 skipped_size = 2;
}
message KfreeFtraceEvent {
  optional uint64 call_site = 1;
  optional uint64 ptr = 2;
}
message KmallocFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional uint64 ptr = 5;
}
message KmallocNodeFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional int32 node = 5;
  optional uint64 ptr = 6;
}
message KmemCacheAllocFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional uint64 ptr = 5;
}
message KmemCacheAllocNodeFtraceEvent {
  optional uint64 bytes_alloc = 1;
  optional uint64 bytes_req = 2;
  optional uint64 call_site = 3;
  optional uint32 gfp_flags = 4;
  optional int32 node = 5;
  optional uint64 ptr = 6;
}
message KmemCacheFreeFtraceEvent {
  optional uint64 call_site = 1;
  optional uint64 ptr = 2;
}
message MigratePagesEndFtraceEvent {
  optional int32 mode = 1;
}
message MigratePagesStartFtraceEvent {
  optional int32 mode = 1;
}
message MigrateRetryFtraceEvent {
  optional int32 tries = 1;
}
message MmPageAllocFtraceEvent {
  optional uint32 gfp_flags = 1;
  optional int32 migratetype = 2;
  optional uint32 order = 3;
  optional uint64 page = 4;
  optional uint64 pfn = 5;
}
message MmPageAllocExtfragFtraceEvent {
  optional int32 alloc_migratetype = 1;
  optional int32 alloc_order = 2;
  optional int32 fallback_migratetype = 3;
  optional int32 fallback_order = 4;
  optional uint64 page = 5;
  optional int32 change_ownership = 6;
  optional uint64 pfn = 7;
}
message MmPageAllocZoneLockedFtraceEvent {
  optional int32 migratetype = 1;
  optional uint32 order = 2;
  optional uint64 page = 3;
  optional uint64 pfn = 4;
}
message MmPageFreeFtraceEvent {
  optional uint32 order = 1;
  optional uint64 page = 2;
  optional uint64 pfn = 3;
}
message MmPageFreeBatchedFtraceEvent {
  optional int32 cold = 1;
  optional uint64 page = 2;
  optional uint64 pfn = 3;
}
message MmPagePcpuDrainFtraceEvent {
  optional int32 migratetype = 1;
  optional uint32 order = 2;
  optional uint64 page = 3;
  optional uint64 pfn = 4;
}
message RssStatFtraceEvent {
  optional int32 member = 1;
  optional int64 size = 2;
}
message IonHeapShrinkFtraceEvent {
  optional string heap_name = 1;
  optional uint64 len = 2;
  optional int64 total_allocated = 3;
}
message IonHeapGrowFtraceEvent {
  optional string heap_name = 1;
  optional uint64 len = 2;
  optional int64 total_allocated = 3;
}

// End of protos/perfetto/trace/ftrace/kmem.proto

// Begin of protos/perfetto/trace/ftrace/lowmemorykiller.proto

message LowmemoryKillFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int64 pagecache_size = 3;
  optional int64 pagecache_limit = 4;
  optional int64 free = 5;
}

// End of protos/perfetto/trace/ftrace/lowmemorykiller.proto

// Begin of protos/perfetto/trace/ftrace/mm_event.proto

message MmEventRecordFtraceEvent {
  optional uint32 avg_lat = 1;
  optional uint32 count = 2;
  optional uint32 max_lat = 3;
  optional uint32 type = 4;
}

// End of protos/perfetto/trace/ftrace/mm_event.proto

// Begin of protos/perfetto/trace/ftrace/power.proto

message CpuFrequencyFtraceEvent {
  optional uint32 state = 1;
  optional uint32 cpu_id = 2;
}
message CpuFrequencyLimitsFtraceEvent {
  optional uint32 min_freq = 1;
  optional uint32 max_freq = 2;
  optional uint32 cpu_id = 3;
}
message CpuIdleFtraceEvent {
  optional uint32 state = 1;
  optional uint32 cpu_id = 2;
}
message ClockEnableFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message ClockDisableFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message ClockSetRateFtraceEvent {
  optional string name = 1;
  optional uint64 state = 2;
  optional uint64 cpu_id = 3;
}
message SuspendResumeFtraceEvent {
  optional string action = 1;
  optional int32 val = 2;
  optional uint32 start = 3;
}

// End of protos/perfetto/trace/ftrace/power.proto

// Begin of protos/perfetto/trace/ftrace/raw_syscalls.proto

message SysEnterFtraceEvent {
  optional int64 id = 1;
}
message SysExitFtraceEvent {
  optional int64 id = 1;
  optional int64 ret = 2;
}

// End of protos/perfetto/trace/ftrace/raw_syscalls.proto

// Begin of protos/perfetto/trace/ftrace/sched.proto

message SchedSwitchFtraceEvent {
  optional string prev_comm = 1;
  optional int32 prev_pid = 2;
  optional int32 prev_prio = 3;
  optional int64 prev_state = 4;
  optional string next_comm = 5;
  optional int32 next_pid = 6;
  optional int32 next_prio = 7;
}
message SchedWakeupFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedBlockedReasonFtraceEvent {
  optional int32 pid = 1;
  optional uint64 caller = 2;
  optional uint32 io_wait = 3;
}
message SchedCpuHotplugFtraceEvent {
  optional int32 affected_cpu = 1;
  optional int32 error = 2;
  optional int32 status = 3;
}
message SchedWakingFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedWakeupNewFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
  optional int32 success = 4;
  optional int32 target_cpu = 5;
}
message SchedProcessExecFtraceEvent {
  optional string filename = 1;
  optional int32 pid = 2;
  optional int32 old_pid = 3;
}
message SchedProcessExitFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 tgid = 3;
  optional int32 prio = 4;
}
message SchedProcessForkFtraceEvent {
  optional string parent_comm = 1;
  optional int32 parent_pid = 2;
  optional string child_comm = 3;
  optional int32 child_pid = 4;
}
message SchedProcessFreeFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
}
message SchedProcessHangFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
}
message SchedProcessWaitFtraceEvent {
  optional string comm = 1;
  optional int32 pid = 2;
  optional int32 prio = 3;
}

// End of protos/perfetto/trace/ftrace/sched.proto

// Begin of protos/perfetto/trace/ftrace/signal.proto

message SignalDeliverFtraceEvent {
  optional int32 code = 1;
  optional uint64 sa_flags = 2;
  optional int32 sig = 3;
}
message SignalGenerateFtraceEvent {
  optional int32 code = 1;
  optional string comm = 2;
  optional int32 group = 3;
  optional int32 pid = 4;
  optional int32 result = 5;
  optional int32 sig = 6;
}

// End of protos/perfetto/trace/ftrace/signal.proto

// Begin of protos/perfetto/trace/ftrace/task.proto

message TaskNewtaskFtraceEvent {
  optional int32 pid = 1;
  optional string comm = 2;
  optional uint64 clone_flags = 3;
  optional int32 oom_score_adj = 4;
}
message TaskRenameFtraceEvent {
  optional int32 pid = 1;
  optional string oldcomm = 2;
  optional string newcomm = 3;
  optional int32 oom_score_adj = 4;
}

// End of protos/perfetto/trace/ftrace/task.proto

// Begin of protos/perfetto/trace/ftrace/vmscan.proto

message MmVmscanDirectReclaimBeginFtraceEvent {
  optional int32 order = 1;
  optional int32 may_writepage = 2;
  optional uint32 gfp_flags = 3;
}
message MmVmscanDirectReclaimEndFtraceEvent {
  optional uint64 nr_reclaimed = 1;
}
message MmVmscanKswapdWakeFtraceEvent {
  optional int32 nid = 1;
  optional int32 order = 2;
}
message MmVmscanKswapdSleepFtraceEvent {
  optional int32 nid = 1;
}

// End of protos/perfetto/trace/ftrace/vmscan.proto

// Begin of protos/perfetto/trace/power/battery_counters.proto

message BatteryCounters {
  // Battery capacity in microampere-hours(Ah). Also known as Coulomb counter.
  optional int64 charge_counter_uah = 1;

  // Remaining battery capacity percentage of total capacity
  optional float capacity_percent = 2;

  // Instantaneous battery current in microamperes(A).
  // Positive values indicate net current entering the battery from a charge
  // source, negative values indicate net current discharging from the battery.
  optional int64 current_ua = 3;

  // Instantaneous battery current in microamperes(A).
  optional int64 current_avg_ua = 4;
}

// End of protos/perfetto/trace/power/battery_counters.proto

// Begin of protos/perfetto/trace/power/power_rails.proto

message PowerRails {

  message RailDescriptor {
    // Index corresponding to the rail
    optional uint32 index = 1;
    // Name of the rail
    optional string rail_name = 2;
    // Name of the subsystem to which this rail belongs
    optional string subsys_name = 3;
    // Hardware sampling rate
    optional uint32 sampling_rate = 4;
  }

  // This is only emitted at the beginning of the trace.
  repeated RailDescriptor rail_descriptor = 1;

  message EnergyData {
    // Index corresponding to RailDescriptor.index
    optional uint32 index = 1;
    // Time since device boot(CLOCK_BOOTTIME) in milli-seconds
    optional uint64 timestamp_ms = 2;
    // Accumulated energy since device boot in microwatt-seconds (uWs)
    optional uint64 energy = 3;
  }

  repeated EnergyData energy_data = 2;
}

// End of protos/perfetto/trace/power/power_rails.proto

// Begin of protos/perfetto/trace/ps/process_stats.proto

// Per-process periodically sampled stats. These samples are wrapped in a
// dedicated message (as opposite to be fields in process_tree.proto) because
// they are dumped at a different rate than cmdline and thread list.
message ProcessStats {
  message Process {
    optional int32 pid = 1;

    // See /proc/[pid]/status in `man 5 proc` for a description of these fields.
    optional uint64 vm_size_kb = 2;
    optional uint64 vm_rss_kb = 3;
    optional uint64 rss_anon_kb = 4;
    optional uint64 rss_file_kb = 5;
    optional uint64 rss_shmem_kb = 6;
    optional uint64 vm_swap_kb = 7;
    optional uint64 vm_locked_kb = 8;
    optional uint64 vm_hwm_kb = 9;
    // When adding a new field remember to update kProcMemCounterSize in
    // the trace processor.

    optional int64 oom_score_adj = 10;
  }
  repeated Process processes = 1;
}

// End of protos/perfetto/trace/ps/process_stats.proto

// Begin of protos/perfetto/trace/ps/process_tree.proto

message ProcessTree {
  // Representation of a thread.
  message Thread {
    // The thread id (as per gettid())
    optional int32 tid = 1;

    // Thread group id (i.e. the PID of the process, == TID of the main thread)
    optional int32 tgid = 3;

    // The name of the thread.
    optional string name = 2;
  }

  // Representation of a process.
  message Process {
    // The UNIX process ID, aka thread group ID (as per getpid()).
    optional int32 pid = 1;

    // The parent process ID, as per getppid().
    optional int32 ppid = 2;

    // The command line for the process, as per /proc/pid/cmdline.
    // If it is a kernel thread there will only be one cmdline field
    // and it will contain /proc/pid/comm.
    repeated string cmdline = 3;

    // No longer used as of Apr 2018, when the dedicated |threads| field was
    // introduced in ProcessTree.
    repeated Thread threads_deprecated = 4 [deprecated = true];
  }

  // List of processes and threads in the client. These lists are incremental
  // and not exhaustive. A process and its threads might show up separately in
  // different ProcessTree messages. A thread might event not show up at all, if
  // no sched_switch activity was detected, for instance:
  // #0 { processes: [{pid: 10, ...}], threads: [{pid: 11, tgid: 10}] }
  // #1 { threads: [{pid: 12, tgid: 10}] }
  // #2 { processes: [{pid: 20, ...}], threads: [{pid: 13, tgid: 10}] }
  repeated Process processes = 1;
  repeated Thread threads = 2;
}

// End of protos/perfetto/trace/ps/process_tree.proto

// Begin of protos/perfetto/trace/sys_stats/sys_stats.proto

// Various Linux system stat counters from /proc.
// The fields in this message can be reported at different rates and with
// different granularity. See sys_stats_config.proto.
message SysStats {
  // Counters from /proc/meminfo. Values are in KB.
  message MeminfoValue {
    optional MeminfoCounters key = 1;
    optional uint64 value = 2;
  };
  repeated MeminfoValue meminfo = 1;

  // Counter from /proc/vmstat. Units are often pages, not KB.
  message VmstatValue {
    optional VmstatCounters key = 1;
    optional uint64 value = 2;
  };
  repeated VmstatValue vmstat = 2;

  // Times in each mode, since boot. Unit: nanoseconds.
  message CpuTimes {
    optional uint32 cpu_id = 1;
    optional uint64 user_ns = 2;         // Time spent in user mode.
    optional uint64 user_ice_ns = 3;     // Time spent in user mode (low prio).
    optional uint64 system_mode_ns = 4;  // Time spent in system mode.
    optional uint64 idle_ns = 5;         // Time spent in the idle task.
    optional uint64 io_wait_ns = 6;      // Time spent waiting for I/O.
    optional uint64 irq_ns = 7;          // Time spent servicing interrupts.
    optional uint64 softirq_ns = 8;      // Time spent servicing softirqs.
  }
  repeated CpuTimes cpu_stat = 3;  // One entry per cpu.

  // Num processes forked since boot.
  // Populated only if FORK_COUNT in config.stat_counters.
  optional uint64 num_forks = 4;

  message InterruptCount {
    optional int32 irq = 1;
    optional uint64 count = 2;
  }

  // Number of interrupts, broken by IRQ number.
  // Populated only if IRQ_COUNTS in config.stat_counters.
  optional uint64 num_irq_total = 5;  // Total num of irqs serviced since boot.
  repeated InterruptCount num_irq = 6;

  // Number of softirqs, broken by softirq number.
  // Populated only if SOFTIRQ_COUNTS in config.stat_counters.
  optional uint64 num_softirq_total = 7;    // Total num of softirqs since boot.
  repeated InterruptCount num_softirq = 8;  // Per-softirq count.
}

// End of protos/perfetto/trace/sys_stats/sys_stats.proto

// Begin of protos/perfetto/trace/trace.proto

message Trace {
  repeated TracePacket packet = 1;

  // Do NOT add any other field here. This is just a convenience wrapper for
  // the use case of a trace being saved to a file. There are other cases
  // (streaming) where TracePacket are directly streamed without being wrapped
  // in a Trace proto. Nothing should ever rely on the full trace, all the
  // logic should be based on TracePacket(s).
}

// End of protos/perfetto/trace/trace.proto

// Begin of protos/perfetto/trace/trace_packet.proto

// The root object emitted by Perfetto. A perfetto trace is just a stream of
// TracePacket(s).
//
// Next reserved id: 11.
// Next id: 41.
message TracePacket {
  // TODO(primiano): in future we should add a timestamp_clock_domain field to
  // allow mixing timestamps from different clock domains.
  optional uint64 timestamp = 8;  // Timestamp [ns].

  oneof data {
    FtraceEventBundle ftrace_events = 1;
    ProcessTree process_tree = 2;
    ProcessStats process_stats = 9;
    InodeFileMap inode_file_map = 4;
    // removed field with id 5
    ClockSnapshot clock_snapshot = 6;
    SysStats sys_stats = 7;

    // IDs up to 32 are reserved for events that are quite frequent because they
    // take only one byte to encode their preamble.

    // removed field with id 33
    FtraceStats ftrace_stats = 34;
    // removed field with id 35
    ProfilePacket profile_packet = 37;
    BatteryCounters battery = 38;
    PowerRails power_rails = 40;
    AndroidLogPacket android_log = 39;

    // This field is emitted at periodic intervals (~10s) and
    // contains always the binary representation of the UUID
    // {82477a76-b28d-42ba-81dc-33326d57a079}. This is used to be able to
    // efficiently partition long traces without having to fully parse them.
    bytes synchronization_marker = 36;

    // This field is only used for testing.
    // removed field with id 268435455  // 2^28 - 1, max field id for protos.
  }

  // Trusted user id of the producer which generated this packet. Keep in sync
  // with TrustedPacket.trusted_uid.
  //
  // TODO(eseckler): Emit this field in a PacketSequenceDescriptor message
  // instead.
  oneof optional_trusted_uid { int32 trusted_uid = 3; };

  // Service-assigned identifier of the packet sequence this packet belongs to.
  // Uniquely identifies a producer + writer pair within the tracing session. A
  // value of zero denotes an invalid ID. Keep in sync with
  // TrustedPacket.trusted_packet_sequence_id.
  oneof optional_trusted_packet_sequence_id {
    uint32 trusted_packet_sequence_id = 10;
  }
}

// End of protos/perfetto/trace/trace_packet.proto

// Begin of protos/perfetto/trace/profiling/profile_packet.proto

message ProfilePacket {
  // either a function or library name.
  repeated InternedString strings = 1;
  message InternedString {
    optional uint64 id = 1;
    optional string str = 2;
  }

  repeated Frame frames = 2;
  message Frame {
    optional uint64 id = 1;  // Interning key
    // E.g. "fopen"
    optional uint64 function_name_id = 2;  // id of string.
    optional uint64 mapping_id = 3;
    optional uint64 rel_pc = 4;
  }

  repeated Callstack callstacks = 3;
  message Callstack {
    optional uint64 id = 1;
    // Frames of this callstack. Bottom frame first.
    repeated uint64 frame_ids = 2;
  }

  repeated Mapping mappings = 4;
  message Mapping {
    optional uint64 id = 1;  // Interning key.
    optional uint64 build_id = 2;  // Interning key.
    optional uint64 offset = 3;
    optional uint64 start = 4;
    optional uint64 end = 5;
    optional uint64 load_bias = 6;
    // E.g. ["system", "lib64", "libc.so"]
    repeated uint64 path_string_ids = 7;  // id of string.
  }

  message HeapSample {
    optional uint64 callstack_id = 1;
    // bytes allocated at this frame.
    optional uint64 self_allocated = 2;
    // bytes freed at this frame.
    optional uint64 self_freed = 3;
    optional uint64 timestamp = 4;  // timestamp [opt]
    optional uint64 alloc_count = 5;
    optional uint64 free_count = 6;
  }

  repeated ProcessHeapSamples process_dumps = 5;
  message ProcessHeapSamples {
    optional uint64 pid = 1;
    repeated HeapSample samples = 2;
  }

  optional bool continued = 6;
  optional uint64 index = 7;
}

// End of protos/perfetto/trace/profiling/profile_packet.proto
