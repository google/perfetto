// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_THIRD_PARTY_PRIMES_PRIMES_TRACING_PROTO_H_
#define PERFETTO_THIRD_PARTY_PRIMES_PRIMES_TRACING_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace third_party {
namespace primes {
namespace pbzero {
class CallSite;
class Duration;
class Fixed128;
class Timestamp;
class Trace_ExternalTraceReference;
class Trace_ExternalTraceReference_EntityIdMapping;
class Trace_Sampling;
class Trace_TraceFailure;
class Trace_TracingOverheadMetrics;
class TraceEdge;
class TraceEdge_Mark;
class TraceEdge_SliceBegin;
class TraceEdge_SliceEnd;
class TraceEdge_TraceEntityDetails;
namespace perfetto_pbzero_enum_Trace_ExternalTraceReference {
enum ExternalTraceType : int32_t;
}  // namespace perfetto_pbzero_enum_Trace_ExternalTraceReference
using Trace_ExternalTraceReference_ExternalTraceType =
    perfetto_pbzero_enum_Trace_ExternalTraceReference::ExternalTraceType;
namespace perfetto_pbzero_enum_TraceEdge_SliceBegin {
enum ExecutorType : int32_t;
}  // namespace perfetto_pbzero_enum_TraceEdge_SliceBegin
using TraceEdge_SliceBegin_ExecutorType =
    perfetto_pbzero_enum_TraceEdge_SliceBegin::ExecutorType;
}  // Namespace pbzero.
}  // Namespace primes.
}  // Namespace third_party.
}  // Namespace perfetto.

namespace perfetto {
namespace third_party {
namespace primes {
namespace pbzero {

namespace perfetto_pbzero_enum_TraceEdge_SliceBegin {
enum ExecutorType : int32_t {
  UNKNOWN = 0,
  MAIN = 1,
  SERIAL = 2,
  CONCURRENT = 3,
};
}  // namespace perfetto_pbzero_enum_TraceEdge_SliceBegin
using TraceEdge_SliceBegin_ExecutorType =
    perfetto_pbzero_enum_TraceEdge_SliceBegin::ExecutorType;

constexpr TraceEdge_SliceBegin_ExecutorType
    TraceEdge_SliceBegin_ExecutorType_MIN =
        TraceEdge_SliceBegin_ExecutorType::UNKNOWN;
constexpr TraceEdge_SliceBegin_ExecutorType
    TraceEdge_SliceBegin_ExecutorType_MAX =
        TraceEdge_SliceBegin_ExecutorType::CONCURRENT;

PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* TraceEdge_SliceBegin_ExecutorType_Name(
    ::perfetto::third_party::primes::pbzero::TraceEdge_SliceBegin_ExecutorType
        value) {
  switch (value) {
    case ::perfetto::third_party::primes::pbzero::
        TraceEdge_SliceBegin_ExecutorType::UNKNOWN:
      return "UNKNOWN";

    case ::perfetto::third_party::primes::pbzero::
        TraceEdge_SliceBegin_ExecutorType::MAIN:
      return "MAIN";

    case ::perfetto::third_party::primes::pbzero::
        TraceEdge_SliceBegin_ExecutorType::SERIAL:
      return "SERIAL";

    case ::perfetto::third_party::primes::pbzero::
        TraceEdge_SliceBegin_ExecutorType::CONCURRENT:
      return "CONCURRENT";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_Trace_ExternalTraceReference {
enum ExternalTraceType : int32_t {
  EXTERNAL_TRACE_TYPE_UNSPECIFIED = 0,
  PRIMES = 1,
  DAPPER = 2,
};
}  // namespace perfetto_pbzero_enum_Trace_ExternalTraceReference
using Trace_ExternalTraceReference_ExternalTraceType =
    perfetto_pbzero_enum_Trace_ExternalTraceReference::ExternalTraceType;

constexpr Trace_ExternalTraceReference_ExternalTraceType
    Trace_ExternalTraceReference_ExternalTraceType_MIN =
        Trace_ExternalTraceReference_ExternalTraceType::
            EXTERNAL_TRACE_TYPE_UNSPECIFIED;
constexpr Trace_ExternalTraceReference_ExternalTraceType
    Trace_ExternalTraceReference_ExternalTraceType_MAX =
        Trace_ExternalTraceReference_ExternalTraceType::DAPPER;

PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* Trace_ExternalTraceReference_ExternalTraceType_Name(
    ::perfetto::third_party::primes::pbzero::
        Trace_ExternalTraceReference_ExternalTraceType value) {
  switch (value) {
    case ::perfetto::third_party::primes::pbzero::
        Trace_ExternalTraceReference_ExternalTraceType::
            EXTERNAL_TRACE_TYPE_UNSPECIFIED:
      return "EXTERNAL_TRACE_TYPE_UNSPECIFIED";

    case ::perfetto::third_party::primes::pbzero::
        Trace_ExternalTraceReference_ExternalTraceType::PRIMES:
      return "PRIMES";

    case ::perfetto::third_party::primes::pbzero::
        Trace_ExternalTraceReference_ExternalTraceType::DAPPER:
      return "DAPPER";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class CallSite_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3> {
 public:
  CallSite_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit CallSite_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit CallSite_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_class_name() const { return at<1>().valid(); }
  ::protozero::ConstChars class_name() const { return at<1>().as_string(); }
  bool has_method_name() const { return at<2>().valid(); }
  ::protozero::ConstChars method_name() const { return at<2>().as_string(); }
  bool has_line_number() const { return at<3>().valid(); }
  int32_t line_number() const { return at<3>().as_int32(); }
};

class CallSite : public ::protozero::Message {
 public:
  using Decoder = CallSite_Decoder;
  enum : int32_t {
    kClassNameFieldNumber = 1,
    kMethodNameFieldNumber = 2,
    kLineNumberFieldNumber = 3,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.CallSite";
  }

  using FieldMetadata_ClassName = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      CallSite>;

  static constexpr FieldMetadata_ClassName kClassName{};
  void set_class_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ClassName::kFieldId, data, size);
  }
  void set_class_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ClassName::kFieldId, chars.data, chars.size);
  }
  void set_class_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ClassName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kString>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_MethodName = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      CallSite>;

  static constexpr FieldMetadata_MethodName kMethodName{};
  void set_method_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_MethodName::kFieldId, data, size);
  }
  void set_method_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_MethodName::kFieldId, chars.data, chars.size);
  }
  void set_method_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MethodName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kString>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_LineNumber = ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      CallSite>;

  static constexpr FieldMetadata_LineNumber kLineNumber{};
  void set_line_number(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LineNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kInt32>::Append(*this,
                                                                   field_id,
                                                                   value);
  }
};

class TraceEdge_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5> {
 public:
  TraceEdge_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit TraceEdge_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit TraceEdge_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_trace_start_offset() const { return at<2>().valid(); }
  ::protozero::ConstBytes trace_start_offset() const {
    return at<2>().as_bytes();
  }
  bool has_slice_begin() const { return at<3>().valid(); }
  ::protozero::ConstBytes slice_begin() const { return at<3>().as_bytes(); }
  bool has_slice_end() const { return at<4>().valid(); }
  ::protozero::ConstBytes slice_end() const { return at<4>().as_bytes(); }
  bool has_mark() const { return at<5>().valid(); }
  ::protozero::ConstBytes mark() const { return at<5>().as_bytes(); }
};

class TraceEdge : public ::protozero::Message {
 public:
  using Decoder = TraceEdge_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kTraceStartOffsetFieldNumber = 2,
    kSliceBeginFieldNumber = 3,
    kSliceEndFieldNumber = 4,
    kMarkFieldNumber = 5,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.TraceEdge";
  }

  using TraceEntityDetails =
      ::perfetto::third_party::primes::pbzero::TraceEdge_TraceEntityDetails;
  using SliceBegin =
      ::perfetto::third_party::primes::pbzero::TraceEdge_SliceBegin;
  using SliceEnd = ::perfetto::third_party::primes::pbzero::TraceEdge_SliceEnd;
  using Mark = ::perfetto::third_party::primes::pbzero::TraceEdge_Mark;

  using FieldMetadata_Id = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TraceEdge>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kUint64>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_TraceStartOffset =
      ::protozero::proto_utils::FieldMetadata<
          2,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Duration,
          TraceEdge>;

  static constexpr FieldMetadata_TraceStartOffset kTraceStartOffset{};
  template <typename T = Duration>
  T* set_trace_start_offset() {
    return BeginNestedMessage<T>(2);
  }

  using FieldMetadata_SliceBegin = ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceEdge_SliceBegin,
      TraceEdge>;

  static constexpr FieldMetadata_SliceBegin kSliceBegin{};
  template <typename T = TraceEdge_SliceBegin>
  T* set_slice_begin() {
    return BeginNestedMessage<T>(3);
  }

  using FieldMetadata_SliceEnd = ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceEdge_SliceEnd,
      TraceEdge>;

  static constexpr FieldMetadata_SliceEnd kSliceEnd{};
  template <typename T = TraceEdge_SliceEnd>
  T* set_slice_end() {
    return BeginNestedMessage<T>(4);
  }

  using FieldMetadata_Mark = ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceEdge_Mark,
      TraceEdge>;

  static constexpr FieldMetadata_Mark kMark{};
  template <typename T = TraceEdge_Mark>
  T* set_mark() {
    return BeginNestedMessage<T>(5);
  }
};

class TraceEdge_Mark_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1> {
 public:
  TraceEdge_Mark_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit TraceEdge_Mark_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit TraceEdge_Mark_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_entity_details() const { return at<1>().valid(); }
  ::protozero::ConstBytes entity_details() const { return at<1>().as_bytes(); }
};

class TraceEdge_Mark : public ::protozero::Message {
 public:
  using Decoder = TraceEdge_Mark_Decoder;
  enum : int32_t {
    kEntityDetailsFieldNumber = 1,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.TraceEdge.Mark";
  }

  using FieldMetadata_EntityDetails = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceEdge_TraceEntityDetails,
      TraceEdge_Mark>;

  static constexpr FieldMetadata_EntityDetails kEntityDetails{};
  template <typename T = TraceEdge_TraceEntityDetails>
  T* set_entity_details() {
    return BeginNestedMessage<T>(1);
  }
};

class TraceEdge_SliceEnd_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4> {
 public:
  TraceEdge_SliceEnd_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit TraceEdge_SliceEnd_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit TraceEdge_SliceEnd_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_total_cpu_time() const { return at<3>().valid(); }
  ::protozero::ConstBytes total_cpu_time() const { return at<3>().as_bytes(); }
  bool has_user_cpu_time() const { return at<4>().valid(); }
  ::protozero::ConstBytes user_cpu_time() const { return at<4>().as_bytes(); }
};

class TraceEdge_SliceEnd : public ::protozero::Message {
 public:
  using Decoder = TraceEdge_SliceEnd_Decoder;
  enum : int32_t {
    kTotalCpuTimeFieldNumber = 3,
    kUserCpuTimeFieldNumber = 4,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.TraceEdge.SliceEnd";
  }

  using FieldMetadata_TotalCpuTime = ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      TraceEdge_SliceEnd>;

  static constexpr FieldMetadata_TotalCpuTime kTotalCpuTime{};
  template <typename T = Duration>
  T* set_total_cpu_time() {
    return BeginNestedMessage<T>(3);
  }

  using FieldMetadata_UserCpuTime = ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      TraceEdge_SliceEnd>;

  static constexpr FieldMetadata_UserCpuTime kUserCpuTime{};
  template <typename T = Duration>
  T* set_user_cpu_time() {
    return BeginNestedMessage<T>(4);
  }
};

class TraceEdge_SliceBegin_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8> {
 public:
  TraceEdge_SliceBegin_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit TraceEdge_SliceBegin_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit TraceEdge_SliceBegin_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_entity_details() const { return at<1>().valid(); }
  ::protozero::ConstBytes entity_details() const { return at<1>().as_bytes(); }
  bool has_thread_id() const { return at<2>().valid(); }
  uint64_t thread_id() const { return at<2>().as_uint64(); }
  bool has_thread_name() const { return at<5>().valid(); }
  ::protozero::ConstChars thread_name() const { return at<5>().as_string(); }
  bool has_executor_name() const { return at<6>().valid(); }
  ::protozero::ConstChars executor_name() const { return at<6>().as_string(); }
  bool has_executor_type() const { return at<7>().valid(); }
  int32_t executor_type() const { return at<7>().as_int32(); }
  bool has_executor_id() const { return at<8>().valid(); }
  uint64_t executor_id() const { return at<8>().as_uint64(); }
  bool has_total_cpu_time() const { return at<3>().valid(); }
  ::protozero::ConstBytes total_cpu_time() const { return at<3>().as_bytes(); }
  bool has_user_cpu_time() const { return at<4>().valid(); }
  ::protozero::ConstBytes user_cpu_time() const { return at<4>().as_bytes(); }
};

class TraceEdge_SliceBegin : public ::protozero::Message {
 public:
  using Decoder = TraceEdge_SliceBegin_Decoder;
  enum : int32_t {
    kEntityDetailsFieldNumber = 1,
    kThreadIdFieldNumber = 2,
    kThreadNameFieldNumber = 5,
    kExecutorNameFieldNumber = 6,
    kExecutorTypeFieldNumber = 7,
    kExecutorIdFieldNumber = 8,
    kTotalCpuTimeFieldNumber = 3,
    kUserCpuTimeFieldNumber = 4,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.TraceEdge.SliceBegin";
  }

  using ExecutorType = ::perfetto::third_party::primes::pbzero::
      TraceEdge_SliceBegin_ExecutorType;
  static inline const char* ExecutorType_Name(ExecutorType value) {
    return ::perfetto::third_party::primes::pbzero::
        TraceEdge_SliceBegin_ExecutorType_Name(value);
  }
  static inline const ExecutorType UNKNOWN = ExecutorType::UNKNOWN;
  static inline const ExecutorType MAIN = ExecutorType::MAIN;
  static inline const ExecutorType SERIAL = ExecutorType::SERIAL;
  static inline const ExecutorType CONCURRENT = ExecutorType::CONCURRENT;

  using FieldMetadata_EntityDetails = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceEdge_TraceEntityDetails,
      TraceEdge_SliceBegin>;

  static constexpr FieldMetadata_EntityDetails kEntityDetails{};
  template <typename T = TraceEdge_TraceEntityDetails>
  T* set_entity_details() {
    return BeginNestedMessage<T>(1);
  }

  using FieldMetadata_ThreadId = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TraceEdge_SliceBegin>;

  static constexpr FieldMetadata_ThreadId kThreadId{};
  void set_thread_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ThreadId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kUint64>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_ThreadName = ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TraceEdge_SliceBegin>;

  static constexpr FieldMetadata_ThreadName kThreadName{};
  void set_thread_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ThreadName::kFieldId, data, size);
  }
  void set_thread_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ThreadName::kFieldId, chars.data, chars.size);
  }
  void set_thread_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ThreadName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kString>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_ExecutorName = ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TraceEdge_SliceBegin>;

  static constexpr FieldMetadata_ExecutorName kExecutorName{};
  void set_executor_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ExecutorName::kFieldId, data, size);
  }
  void set_executor_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ExecutorName::kFieldId, chars.data, chars.size);
  }
  void set_executor_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ExecutorName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kString>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_ExecutorType = ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      TraceEdge_SliceBegin_ExecutorType,
      TraceEdge_SliceBegin>;

  static constexpr FieldMetadata_ExecutorType kExecutorType{};
  void set_executor_type(TraceEdge_SliceBegin_ExecutorType value) {
    static constexpr uint32_t field_id = FieldMetadata_ExecutorType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kEnum>::Append(*this,
                                                                  field_id,
                                                                  value);
  }

  using FieldMetadata_ExecutorId = ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TraceEdge_SliceBegin>;

  static constexpr FieldMetadata_ExecutorId kExecutorId{};
  void set_executor_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ExecutorId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kUint64>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_TotalCpuTime = ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      TraceEdge_SliceBegin>;

  static constexpr FieldMetadata_TotalCpuTime kTotalCpuTime{};
  template <typename T = Duration>
  T* set_total_cpu_time() {
    return BeginNestedMessage<T>(3);
  }

  using FieldMetadata_UserCpuTime = ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      TraceEdge_SliceBegin>;

  static constexpr FieldMetadata_UserCpuTime kUserCpuTime{};
  template <typename T = Duration>
  T* set_user_cpu_time() {
    return BeginNestedMessage<T>(4);
  }
};

class TraceEdge_TraceEntityDetails_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5> {
 public:
  TraceEdge_TraceEntityDetails_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit TraceEdge_TraceEntityDetails_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit TraceEdge_TraceEntityDetails_Decoder(
      const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_parent_id() const { return at<2>().valid(); }
  uint64_t parent_id() const { return at<2>().as_uint64(); }
  bool has_follows_from_ids() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> follows_from_ids() const {
    return GetRepeated<uint64_t>(3);
  }
  bool has_flow_ids() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> flow_ids() const {
    return GetRepeated<uint64_t>(4);
  }
  bool has_call_site() const { return at<5>().valid(); }
  ::protozero::ConstBytes call_site() const { return at<5>().as_bytes(); }
};

class TraceEdge_TraceEntityDetails : public ::protozero::Message {
 public:
  using Decoder = TraceEdge_TraceEntityDetails_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kParentIdFieldNumber = 2,
    kFollowsFromIdsFieldNumber = 3,
    kFlowIdsFieldNumber = 4,
    kCallSiteFieldNumber = 5,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.TraceEdge.TraceEntityDetails";
  }

  using FieldMetadata_Name = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TraceEdge_TraceEntityDetails>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kString>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_ParentId = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TraceEdge_TraceEntityDetails>;

  static constexpr FieldMetadata_ParentId kParentId{};
  void set_parent_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ParentId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kUint64>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_FollowsFromIds = ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TraceEdge_TraceEntityDetails>;

  static constexpr FieldMetadata_FollowsFromIds kFollowsFromIds{};
  void add_follows_from_ids(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FollowsFromIds::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kUint64>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_FlowIds = ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TraceEdge_TraceEntityDetails>;

  static constexpr FieldMetadata_FlowIds kFlowIds{};
  void add_flow_ids(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FlowIds::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kUint64>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_CallSite = ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CallSite,
      TraceEdge_TraceEntityDetails>;

  static constexpr FieldMetadata_CallSite kCallSite{};
  template <typename T = CallSite>
  T* set_call_site() {
    return BeginNestedMessage<T>(5);
  }
};

class Trace_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/12> {
 public:
  Trace_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Trace_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Trace_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_sampling() const { return at<10>().valid(); }
  ::protozero::ConstBytes sampling() const { return at<10>().as_bytes(); }
  bool has_external_trace_references() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes>
  external_trace_references() const {
    return GetRepeated<::protozero::ConstBytes>(8);
  }
  bool has_tracing_overhead_metrics() const { return at<9>().valid(); }
  ::protozero::ConstBytes tracing_overhead_metrics() const {
    return at<9>().as_bytes();
  }
  bool has_start_time() const { return at<4>().valid(); }
  ::protozero::ConstBytes start_time() const { return at<4>().as_bytes(); }
  bool has_duration() const { return at<11>().valid(); }
  ::protozero::ConstBytes duration() const { return at<11>().as_bytes(); }
  bool has_num_dropped_entities() const { return at<5>().valid(); }
  int32_t num_dropped_entities() const { return at<5>().as_int32(); }
  bool has_trace_failure() const { return at<6>().valid(); }
  ::protozero::ConstBytes trace_failure() const { return at<6>().as_bytes(); }
  bool has_edges() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> edges() const {
    return GetRepeated<::protozero::ConstBytes>(7);
  }
  bool has_root_call_site() const { return at<12>().valid(); }
  ::protozero::ConstBytes root_call_site() const { return at<12>().as_bytes(); }
};

class Trace : public ::protozero::Message {
 public:
  using Decoder = Trace_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSamplingFieldNumber = 10,
    kExternalTraceReferencesFieldNumber = 8,
    kTracingOverheadMetricsFieldNumber = 9,
    kStartTimeFieldNumber = 4,
    kDurationFieldNumber = 11,
    kNumDroppedEntitiesFieldNumber = 5,
    kTraceFailureFieldNumber = 6,
    kEdgesFieldNumber = 7,
    kRootCallSiteFieldNumber = 12,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Trace";
  }

  using Sampling = ::perfetto::third_party::primes::pbzero::Trace_Sampling;
  using ExternalTraceReference =
      ::perfetto::third_party::primes::pbzero::Trace_ExternalTraceReference;
  using TracingOverheadMetrics =
      ::perfetto::third_party::primes::pbzero::Trace_TracingOverheadMetrics;
  using TraceFailure =
      ::perfetto::third_party::primes::pbzero::Trace_TraceFailure;

  using FieldMetadata_Id = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      Trace>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kFixed64>::Append(*this,
                                                                     field_id,
                                                                     value);
  }

  using FieldMetadata_Name = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      Trace>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kString>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_Sampling = ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Trace_Sampling,
      Trace>;

  static constexpr FieldMetadata_Sampling kSampling{};
  template <typename T = Trace_Sampling>
  T* set_sampling() {
    return BeginNestedMessage<T>(10);
  }

  using FieldMetadata_ExternalTraceReferences =
      ::protozero::proto_utils::FieldMetadata<
          8,
          ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Trace_ExternalTraceReference,
          Trace>;

  static constexpr FieldMetadata_ExternalTraceReferences
      kExternalTraceReferences{};
  template <typename T = Trace_ExternalTraceReference>
  T* add_external_trace_references() {
    return BeginNestedMessage<T>(8);
  }

  using FieldMetadata_TracingOverheadMetrics =
      ::protozero::proto_utils::FieldMetadata<
          9,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Trace_TracingOverheadMetrics,
          Trace>;

  static constexpr FieldMetadata_TracingOverheadMetrics
      kTracingOverheadMetrics{};
  template <typename T = Trace_TracingOverheadMetrics>
  T* set_tracing_overhead_metrics() {
    return BeginNestedMessage<T>(9);
  }

  using FieldMetadata_StartTime = ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Timestamp,
      Trace>;

  static constexpr FieldMetadata_StartTime kStartTime{};
  template <typename T = Timestamp>
  T* set_start_time() {
    return BeginNestedMessage<T>(4);
  }

  using FieldMetadata_Duration = ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      Trace>;

  static constexpr FieldMetadata_Duration kDuration{};
  template <typename T = Duration>
  T* set_duration() {
    return BeginNestedMessage<T>(11);
  }

  using FieldMetadata_NumDroppedEntities =
      ::protozero::proto_utils::FieldMetadata<
          5,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kInt32,
          int32_t,
          Trace>;

  static constexpr FieldMetadata_NumDroppedEntities kNumDroppedEntities{};
  void set_num_dropped_entities(int32_t value) {
    static constexpr uint32_t field_id =
        FieldMetadata_NumDroppedEntities::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kInt32>::Append(*this,
                                                                   field_id,
                                                                   value);
  }

  using FieldMetadata_TraceFailure = ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Trace_TraceFailure,
      Trace>;

  static constexpr FieldMetadata_TraceFailure kTraceFailure{};
  template <typename T = Trace_TraceFailure>
  T* set_trace_failure() {
    return BeginNestedMessage<T>(6);
  }

  using FieldMetadata_Edges = ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceEdge,
      Trace>;

  static constexpr FieldMetadata_Edges kEdges{};
  template <typename T = TraceEdge>
  T* add_edges() {
    return BeginNestedMessage<T>(7);
  }

  using FieldMetadata_RootCallSite = ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CallSite,
      Trace>;

  static constexpr FieldMetadata_RootCallSite kRootCallSite{};
  template <typename T = CallSite>
  T* set_root_call_site() {
    return BeginNestedMessage<T>(12);
  }
};

class Trace_TraceFailure_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1> {
 public:
  Trace_TraceFailure_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Trace_TraceFailure_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Trace_TraceFailure_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timed_out_after() const { return at<1>().valid(); }
  ::protozero::ConstBytes timed_out_after() const { return at<1>().as_bytes(); }
};

class Trace_TraceFailure : public ::protozero::Message {
 public:
  using Decoder = Trace_TraceFailure_Decoder;
  enum : int32_t {
    kTimedOutAfterFieldNumber = 1,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Trace.TraceFailure";
  }

  using FieldMetadata_TimedOutAfter = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      Trace_TraceFailure>;

  static constexpr FieldMetadata_TimedOutAfter kTimedOutAfter{};
  template <typename T = Duration>
  T* set_timed_out_after() {
    return BeginNestedMessage<T>(1);
  }
};

class Trace_TracingOverheadMetrics_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/12> {
 public:
  Trace_TracingOverheadMetrics_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Trace_TracingOverheadMetrics_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Trace_TracingOverheadMetrics_Decoder(
      const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_capture_trace_context_avg() const { return at<1>().valid(); }
  ::protozero::ConstBytes capture_trace_context_avg() const {
    return at<1>().as_bytes();
  }
  bool has_capture_trace_context_max() const { return at<2>().valid(); }
  ::protozero::ConstBytes capture_trace_context_max() const {
    return at<2>().as_bytes();
  }
  bool has_capture_trace_context_count() const { return at<3>().valid(); }
  int64_t capture_trace_context_count() const { return at<3>().as_int64(); }
  bool has_install_trace_context_avg() const { return at<4>().valid(); }
  ::protozero::ConstBytes install_trace_context_avg() const {
    return at<4>().as_bytes();
  }
  bool has_install_trace_context_max() const { return at<5>().valid(); }
  ::protozero::ConstBytes install_trace_context_max() const {
    return at<5>().as_bytes();
  }
  bool has_install_trace_context_count() const { return at<6>().valid(); }
  int64_t install_trace_context_count() const { return at<6>().as_int64(); }
  bool has_add_slice_begin_avg() const { return at<7>().valid(); }
  ::protozero::ConstBytes add_slice_begin_avg() const {
    return at<7>().as_bytes();
  }
  bool has_add_slice_begin_max() const { return at<8>().valid(); }
  ::protozero::ConstBytes add_slice_begin_max() const {
    return at<8>().as_bytes();
  }
  bool has_add_slice_end_avg() const { return at<9>().valid(); }
  ::protozero::ConstBytes add_slice_end_avg() const {
    return at<9>().as_bytes();
  }
  bool has_add_slice_end_max() const { return at<10>().valid(); }
  ::protozero::ConstBytes add_slice_end_max() const {
    return at<10>().as_bytes();
  }
  bool has_add_mark_avg() const { return at<11>().valid(); }
  ::protozero::ConstBytes add_mark_avg() const { return at<11>().as_bytes(); }
  bool has_add_mark_max() const { return at<12>().valid(); }
  ::protozero::ConstBytes add_mark_max() const { return at<12>().as_bytes(); }
};

class Trace_TracingOverheadMetrics : public ::protozero::Message {
 public:
  using Decoder = Trace_TracingOverheadMetrics_Decoder;
  enum : int32_t {
    kCaptureTraceContextAvgFieldNumber = 1,
    kCaptureTraceContextMaxFieldNumber = 2,
    kCaptureTraceContextCountFieldNumber = 3,
    kInstallTraceContextAvgFieldNumber = 4,
    kInstallTraceContextMaxFieldNumber = 5,
    kInstallTraceContextCountFieldNumber = 6,
    kAddSliceBeginAvgFieldNumber = 7,
    kAddSliceBeginMaxFieldNumber = 8,
    kAddSliceEndAvgFieldNumber = 9,
    kAddSliceEndMaxFieldNumber = 10,
    kAddMarkAvgFieldNumber = 11,
    kAddMarkMaxFieldNumber = 12,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Trace.TracingOverheadMetrics";
  }

  using FieldMetadata_CaptureTraceContextAvg =
      ::protozero::proto_utils::FieldMetadata<
          1,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Duration,
          Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_CaptureTraceContextAvg
      kCaptureTraceContextAvg{};
  template <typename T = Duration>
  T* set_capture_trace_context_avg() {
    return BeginNestedMessage<T>(1);
  }

  using FieldMetadata_CaptureTraceContextMax =
      ::protozero::proto_utils::FieldMetadata<
          2,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Duration,
          Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_CaptureTraceContextMax
      kCaptureTraceContextMax{};
  template <typename T = Duration>
  T* set_capture_trace_context_max() {
    return BeginNestedMessage<T>(2);
  }

  using FieldMetadata_CaptureTraceContextCount =
      ::protozero::proto_utils::FieldMetadata<
          3,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kInt64,
          int64_t,
          Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_CaptureTraceContextCount
      kCaptureTraceContextCount{};
  void set_capture_trace_context_count(int64_t value) {
    static constexpr uint32_t field_id =
        FieldMetadata_CaptureTraceContextCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kInt64>::Append(*this,
                                                                   field_id,
                                                                   value);
  }

  using FieldMetadata_InstallTraceContextAvg =
      ::protozero::proto_utils::FieldMetadata<
          4,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Duration,
          Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_InstallTraceContextAvg
      kInstallTraceContextAvg{};
  template <typename T = Duration>
  T* set_install_trace_context_avg() {
    return BeginNestedMessage<T>(4);
  }

  using FieldMetadata_InstallTraceContextMax =
      ::protozero::proto_utils::FieldMetadata<
          5,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Duration,
          Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_InstallTraceContextMax
      kInstallTraceContextMax{};
  template <typename T = Duration>
  T* set_install_trace_context_max() {
    return BeginNestedMessage<T>(5);
  }

  using FieldMetadata_InstallTraceContextCount =
      ::protozero::proto_utils::FieldMetadata<
          6,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kInt64,
          int64_t,
          Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_InstallTraceContextCount
      kInstallTraceContextCount{};
  void set_install_trace_context_count(int64_t value) {
    static constexpr uint32_t field_id =
        FieldMetadata_InstallTraceContextCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kInt64>::Append(*this,
                                                                   field_id,
                                                                   value);
  }

  using FieldMetadata_AddSliceBeginAvg =
      ::protozero::proto_utils::FieldMetadata<
          7,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Duration,
          Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_AddSliceBeginAvg kAddSliceBeginAvg{};
  template <typename T = Duration>
  T* set_add_slice_begin_avg() {
    return BeginNestedMessage<T>(7);
  }

  using FieldMetadata_AddSliceBeginMax =
      ::protozero::proto_utils::FieldMetadata<
          8,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Duration,
          Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_AddSliceBeginMax kAddSliceBeginMax{};
  template <typename T = Duration>
  T* set_add_slice_begin_max() {
    return BeginNestedMessage<T>(8);
  }

  using FieldMetadata_AddSliceEndAvg = ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_AddSliceEndAvg kAddSliceEndAvg{};
  template <typename T = Duration>
  T* set_add_slice_end_avg() {
    return BeginNestedMessage<T>(9);
  }

  using FieldMetadata_AddSliceEndMax = ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_AddSliceEndMax kAddSliceEndMax{};
  template <typename T = Duration>
  T* set_add_slice_end_max() {
    return BeginNestedMessage<T>(10);
  }

  using FieldMetadata_AddMarkAvg = ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_AddMarkAvg kAddMarkAvg{};
  template <typename T = Duration>
  T* set_add_mark_avg() {
    return BeginNestedMessage<T>(11);
  }

  using FieldMetadata_AddMarkMax = ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Duration,
      Trace_TracingOverheadMetrics>;

  static constexpr FieldMetadata_AddMarkMax kAddMarkMax{};
  template <typename T = Duration>
  T* set_add_mark_max() {
    return BeginNestedMessage<T>(12);
  }
};

class Trace_ExternalTraceReference_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4> {
 public:
  Trace_ExternalTraceReference_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Trace_ExternalTraceReference_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Trace_ExternalTraceReference_Decoder(
      const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_type() const { return at<1>().valid(); }
  int32_t type() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  uint64_t id() const { return at<2>().as_uint64(); }
  bool has_id_128() const { return at<3>().valid(); }
  ::protozero::ConstBytes id_128() const { return at<3>().as_bytes(); }
  bool has_entity_id_mappings() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes>
  entity_id_mappings() const {
    return GetRepeated<::protozero::ConstBytes>(4);
  }
};

class Trace_ExternalTraceReference : public ::protozero::Message {
 public:
  using Decoder = Trace_ExternalTraceReference_Decoder;
  enum : int32_t {
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kId128FieldNumber = 3,
    kEntityIdMappingsFieldNumber = 4,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Trace.ExternalTraceReference";
  }

  using EntityIdMapping = ::perfetto::third_party::primes::pbzero::
      Trace_ExternalTraceReference_EntityIdMapping;

  using ExternalTraceType = ::perfetto::third_party::primes::pbzero::
      Trace_ExternalTraceReference_ExternalTraceType;
  static inline const char* ExternalTraceType_Name(ExternalTraceType value) {
    return ::perfetto::third_party::primes::pbzero::
        Trace_ExternalTraceReference_ExternalTraceType_Name(value);
  }
  static inline const ExternalTraceType EXTERNAL_TRACE_TYPE_UNSPECIFIED =
      ExternalTraceType::EXTERNAL_TRACE_TYPE_UNSPECIFIED;
  static inline const ExternalTraceType PRIMES = ExternalTraceType::PRIMES;
  static inline const ExternalTraceType DAPPER = ExternalTraceType::DAPPER;

  using FieldMetadata_Type = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      Trace_ExternalTraceReference_ExternalTraceType,
      Trace_ExternalTraceReference>;

  static constexpr FieldMetadata_Type kType{};
  void set_type(Trace_ExternalTraceReference_ExternalTraceType value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kEnum>::Append(*this,
                                                                  field_id,
                                                                  value);
  }

  using FieldMetadata_Id = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      Trace_ExternalTraceReference>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kFixed64>::Append(*this,
                                                                     field_id,
                                                                     value);
  }

  using FieldMetadata_Id128 = ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Fixed128,
      Trace_ExternalTraceReference>;

  static constexpr FieldMetadata_Id128 kId128{};
  template <typename T = Fixed128>
  T* set_id_128() {
    return BeginNestedMessage<T>(3);
  }

  using FieldMetadata_EntityIdMappings =
      ::protozero::proto_utils::FieldMetadata<
          4,
          ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
          ::protozero::proto_utils::ProtoSchemaType::kMessage,
          Trace_ExternalTraceReference_EntityIdMapping,
          Trace_ExternalTraceReference>;

  static constexpr FieldMetadata_EntityIdMappings kEntityIdMappings{};
  template <typename T = Trace_ExternalTraceReference_EntityIdMapping>
  T* add_entity_id_mappings() {
    return BeginNestedMessage<T>(4);
  }
};

class Trace_ExternalTraceReference_EntityIdMapping_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2> {
 public:
  Trace_ExternalTraceReference_EntityIdMapping_Decoder(const uint8_t* data,
                                                       size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Trace_ExternalTraceReference_EntityIdMapping_Decoder(
      const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Trace_ExternalTraceReference_EntityIdMapping_Decoder(
      const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_from_entity_id() const { return at<1>().valid(); }
  uint64_t from_entity_id() const { return at<1>().as_uint64(); }
  bool has_to_entity_id() const { return at<2>().valid(); }
  uint64_t to_entity_id() const { return at<2>().as_uint64(); }
};

class Trace_ExternalTraceReference_EntityIdMapping
    : public ::protozero::Message {
 public:
  using Decoder = Trace_ExternalTraceReference_EntityIdMapping_Decoder;
  enum : int32_t {
    kFromEntityIdFieldNumber = 1,
    kToEntityIdFieldNumber = 2,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Trace.ExternalTraceReference."
           "EntityIdMapping";
  }

  using FieldMetadata_FromEntityId = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Trace_ExternalTraceReference_EntityIdMapping>;

  static constexpr FieldMetadata_FromEntityId kFromEntityId{};
  void set_from_entity_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FromEntityId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kUint64>::Append(*this,
                                                                    field_id,
                                                                    value);
  }

  using FieldMetadata_ToEntityId = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Trace_ExternalTraceReference_EntityIdMapping>;

  static constexpr FieldMetadata_ToEntityId kToEntityId{};
  void set_to_entity_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ToEntityId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kUint64>::Append(*this,
                                                                    field_id,
                                                                    value);
  }
};

class Trace_Sampling_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2> {
 public:
  Trace_Sampling_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Trace_Sampling_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Trace_Sampling_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_process_sampling_probability() const { return at<1>().valid(); }
  float process_sampling_probability() const { return at<1>().as_float(); }
  bool has_trace_sampling_probability() const { return at<2>().valid(); }
  float trace_sampling_probability() const { return at<2>().as_float(); }
};

class Trace_Sampling : public ::protozero::Message {
 public:
  using Decoder = Trace_Sampling_Decoder;
  enum : int32_t {
    kProcessSamplingProbabilityFieldNumber = 1,
    kTraceSamplingProbabilityFieldNumber = 2,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Trace.Sampling";
  }

  using FieldMetadata_ProcessSamplingProbability =
      ::protozero::proto_utils::FieldMetadata<
          1,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kFloat,
          float,
          Trace_Sampling>;

  static constexpr FieldMetadata_ProcessSamplingProbability
      kProcessSamplingProbability{};
  void set_process_sampling_probability(float value) {
    static constexpr uint32_t field_id =
        FieldMetadata_ProcessSamplingProbability::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kFloat>::Append(*this,
                                                                   field_id,
                                                                   value);
  }

  using FieldMetadata_TraceSamplingProbability =
      ::protozero::proto_utils::FieldMetadata<
          2,
          ::protozero::proto_utils::RepetitionType::kNotRepeated,
          ::protozero::proto_utils::ProtoSchemaType::kFloat,
          float,
          Trace_Sampling>;

  static constexpr FieldMetadata_TraceSamplingProbability
      kTraceSamplingProbability{};
  void set_trace_sampling_probability(float value) {
    static constexpr uint32_t field_id =
        FieldMetadata_TraceSamplingProbability::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kFloat>::Append(*this,
                                                                   field_id,
                                                                   value);
  }
};

class Timestamp_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2> {
 public:
  Timestamp_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Timestamp_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Timestamp_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_seconds() const { return at<1>().valid(); }
  int64_t seconds() const { return at<1>().as_int64(); }
  bool has_nanos() const { return at<2>().valid(); }
  int32_t nanos() const { return at<2>().as_int32(); }
};

class Timestamp : public ::protozero::Message {
 public:
  using Decoder = Timestamp_Decoder;
  enum : int32_t {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Timestamp";
  }

  using FieldMetadata_Seconds = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Timestamp>;

  static constexpr FieldMetadata_Seconds kSeconds{};
  void set_seconds(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Seconds::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kInt64>::Append(*this,
                                                                   field_id,
                                                                   value);
  }

  using FieldMetadata_Nanos = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      Timestamp>;

  static constexpr FieldMetadata_Nanos kNanos{};
  void set_nanos(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Nanos::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kInt32>::Append(*this,
                                                                   field_id,
                                                                   value);
  }
};

class Duration_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2> {
 public:
  Duration_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Duration_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Duration_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_seconds() const { return at<1>().valid(); }
  int64_t seconds() const { return at<1>().as_int64(); }
  bool has_nanos() const { return at<2>().valid(); }
  int32_t nanos() const { return at<2>().as_int32(); }
};

class Duration : public ::protozero::Message {
 public:
  using Decoder = Duration_Decoder;
  enum : int32_t {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Duration";
  }

  using FieldMetadata_Seconds = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Duration>;

  static constexpr FieldMetadata_Seconds kSeconds{};
  void set_seconds(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Seconds::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kInt64>::Append(*this,
                                                                   field_id,
                                                                   value);
  }

  using FieldMetadata_Nanos = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      Duration>;

  static constexpr FieldMetadata_Nanos kNanos{};
  void set_nanos(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Nanos::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kInt32>::Append(*this,
                                                                   field_id,
                                                                   value);
  }
};

class Fixed128_Decoder
    : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2> {
 public:
  Fixed128_Decoder(const uint8_t* data, size_t len)
      : TypedProtoDecoder(data, len) {}
  explicit Fixed128_Decoder(const std::string& raw)
      : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()),
                          raw.size()) {}
  explicit Fixed128_Decoder(const ::protozero::ConstBytes& raw)
      : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_high() const { return at<1>().valid(); }
  uint64_t high() const { return at<1>().as_uint64(); }
  bool has_low() const { return at<2>().valid(); }
  uint64_t low() const { return at<2>().as_uint64(); }
};

class Fixed128 : public ::protozero::Message {
 public:
  using Decoder = Fixed128_Decoder;
  enum : int32_t {
    kHighFieldNumber = 1,
    kLowFieldNumber = 2,
  };
  static constexpr const char* GetName() {
    return ".perfetto.third_party.primes.Fixed128";
  }

  using FieldMetadata_High = ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      Fixed128>;

  static constexpr FieldMetadata_High kHigh{};
  void set_high(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_High::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kFixed64>::Append(*this,
                                                                     field_id,
                                                                     value);
  }

  using FieldMetadata_Low = ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      Fixed128>;

  static constexpr FieldMetadata_Low kLow{};
  void set_low(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Low::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
        ::protozero::proto_utils::ProtoSchemaType::kFixed64>::Append(*this,
                                                                     field_id,
                                                                     value);
  }
};

}  // namespace pbzero
}  // namespace primes
}  // namespace third_party
}  // namespace perfetto
#endif  // Include guard.
