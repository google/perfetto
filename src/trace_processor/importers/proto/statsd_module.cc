#include "src/trace_processor/importers/proto/statsd_module.h"

#include <cstddef>
#include <cstdint>
#include <iostream>
#include <optional>
#include <string>
#include <utility>
#include <vector>

#include "perfetto/base/logging.h"
#include "perfetto/base/status.h"
#include "perfetto/ext/base/string_utils.h"
#include "perfetto/ext/base/string_view.h"
#include "perfetto/protozero/field.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
#include "perfetto/trace_processor/ref_counted.h"
#include "perfetto/trace_processor/trace_blob.h"
#include "protos/perfetto/trace/statsd/statsd_atom.pbzero.h"
#include "protos/perfetto/trace/trace_packet.pbzero.h"
#include "src/trace_processor/importers/common/args_tracker.h"
#include "src/trace_processor/importers/common/parser_types.h"
#include "src/trace_processor/importers/common/slice_tracker.h"
#include "src/trace_processor/importers/common/track_tracker.h"
#include "src/trace_processor/importers/common/tracks.h"
#include "src/trace_processor/importers/proto/args_parser.h"
#include "src/trace_processor/importers/proto/atoms.descriptor.h"
#include "src/trace_processor/importers/proto/packet_sequence_state_generation.h"
#include "src/trace_processor/importers/proto/proto_importer_module.h"
#include "src/trace_processor/sorter/trace_sorter.h"
#include "src/trace_processor/storage/stats.h"
#include "src/trace_processor/storage/trace_storage.h"
#include "src/trace_processor/util/descriptors.h"
#include "src/trace_processor/util/proto_to_args_parser.h"

namespace perfetto::trace_processor {
namespace {

constexpr const char* kAtomProtoName = ".android.os.statsd.Atom";

// The hardcoded descriptor bytes provided by the user.
const unsigned char kTestAtomDescriptor[] = 
// {
//     0x0a, 0xef, 0x01, 0x0a, 0x3e, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79,
//     0x5f, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x70,
//     0x72, 0x6f, 0x74, 0x6f, 0x12, 0x3c, 0x6c, 0x6f, 0x67, 0x73, 0x2e, 0x70,
//     0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73,
//     0x73, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x73, 0x74,
//     0x61, 0x74, 0x73, 0x2e, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d,
//     0x2e, 0x77, 0x65, 0x73, 0x74, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x62,
//     0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x1a, 0x24, 0x73, 0x79, 0x6e, 0x74,
//     0x68, 0x65, 0x74, 0x69, 0x63, 0x2f, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69,
//     0x64, 0x2f, 0x6f, 0x73, 0x2f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x64, 0x2f,
//     0x61, 0x74, 0x6f, 0x6d, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa1,
//     0x01, 0x0a, 0x1c, 0x52, 0x61, 0x77, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72,
//     0x79, 0x47, 0x61, 0x75, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52,
//     0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x12, 0x2c, 0x0a, 0x17, 0x73,
//     0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x5f,
//     0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6e, 0x61, 0x6e, 0x6f, 0x73, 0x18, 0x01,
//     0x20, 0x03, 0x28, 0x03, 0x52, 0x14, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d,
//     0x43, 0x6c, 0x6f, 0x63, 0x6b, 0x54, 0x69, 0x6d, 0x65, 0x4e, 0x61, 0x6e,
//     0x6f, 0x73, 0x12, 0x24, 0x0a, 0x0d, 0x76, 0x6f, 0x6c, 0x74, 0x61, 0x67,
//     0x65, 0x5f, 0x76, 0x6f, 0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
//     0x02, 0x52, 0x0c, 0x76, 0x6f, 0x6c, 0x74, 0x61, 0x67, 0x65, 0x56, 0x6f,
//     0x6c, 0x74, 0x73, 0x12, 0x2d, 0x0a, 0x11, 0x63, 0x75, 0x72, 0x72, 0x65,
//     0x6e, 0x74, 0x5f, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x61, 0x6d, 0x70, 0x73,
//     0x18, 0x03, 0x20, 0x03, 0x28, 0x02, 0x52, 0x10, 0x63, 0x75, 0x72, 0x72,
//     0x65, 0x6e, 0x74, 0x4d, 0x69, 0x6c, 0x6c, 0x69, 0x61, 0x6d, 0x70, 0x73,
//     0x3a, 0x8a, 0x01, 0x0a, 0x20, 0x72, 0x61, 0x77, 0x5f, 0x62, 0x61, 0x74,
//     0x74, 0x65, 0x72, 0x79, 0x5f, 0x67, 0x61, 0x75, 0x67, 0x65, 0x5f, 0x73,
//     0x74, 0x61, 0x74, 0x73, 0x5f, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65,
//     0x64, 0x12, 0x17, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e,
//     0x6f, 0x73, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x64, 0x2e, 0x41, 0x74,
//     0x6f, 0x6d, 0x18, 0xbd, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x4a, 0x2e,
//     0x6c, 0x6f, 0x67, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x77,
//     0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x61, 0x6e, 0x64, 0x72,
//     0x6f, 0x69, 0x64, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x70, 0x6c,
//     0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x77, 0x65, 0x73, 0x74, 0x77,
//     0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79,
//     0x2e, 0x52, 0x61, 0x77, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x47,
//     0x61, 0x75, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x70,
//     0x6f, 0x72, 0x74, 0x65, 0x64, 0x52, 0x1c, 0x72, 0x61, 0x77, 0x42, 0x61,
//     0x74, 0x74, 0x65, 0x72, 0x79, 0x47, 0x61, 0x75, 0x67, 0x65, 0x53, 0x74,
//     0x61, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x09,
//     0x65, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x10, 0xe7, 0x0f,
// };
//correct
// {
//   0x0a, 0xf0, 0x03, 0x0a, 0x60, 0x6c, 0x6f, 0x67, 0x73, 0x2f, 0x70, 0x72,
//   0x6f, 0x74, 0x6f, 0x2f, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73,
//   0x2f, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2f, 0x73, 0x74, 0x61,
//   0x74, 0x73, 0x2f, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x2f,
//   0x77, 0x65, 0x73, 0x74, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2f, 0x61, 0x74,
//   0x6f, 0x6d, 0x73, 0x2f, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x2f,
//   0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x5f, 0x65, 0x78, 0x74, 0x65,
//   0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x61, 0x74, 0x6f, 0x6d, 0x73, 0x2e,
//   0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x3c, 0x6c, 0x6f, 0x67, 0x73, 0x2e,
//   0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65,
//   0x73, 0x73, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x73,
//   0x74, 0x61, 0x74, 0x73, 0x2e, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72,
//   0x6d, 0x2e, 0x77, 0x65, 0x73, 0x74, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2e,
//   0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x22, 0x71, 0x0a, 0x1c, 0x52,
//   0x61, 0x77, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x47, 0x61, 0x75,
//   0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6f, 0x72,
//   0x74, 0x65, 0x64, 0x12, 0x1f, 0x0a, 0x17, 0x73, 0x79, 0x73, 0x74, 0x65,
//   0x6d, 0x5f, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65,
//   0x5f, 0x6e, 0x61, 0x6e, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x03,
//   0x12, 0x15, 0x0a, 0x0d, 0x76, 0x6f, 0x6c, 0x74, 0x61, 0x67, 0x65, 0x5f,
//   0x76, 0x6f, 0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x02, 0x12,
//   0x19, 0x0a, 0x11, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6d,
//   0x69, 0x6c, 0x6c, 0x69, 0x61, 0x6d, 0x70, 0x73, 0x18, 0x03, 0x20, 0x03,
//   0x28, 0x02, 0x3a, 0x9e, 0x01, 0x0a, 0x20, 0x72, 0x61, 0x77, 0x5f, 0x62,
//   0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x5f, 0x67, 0x61, 0x75, 0x67, 0x65,
//   0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x72, 0x65, 0x70, 0x6f, 0x72,
//   0x74, 0x65, 0x64, 0x12, 0x17, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69,
//   0x64, 0x2e, 0x6f, 0x73, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x64, 0x2e,
//   0x41, 0x74, 0x6f, 0x6d, 0x18, 0xbd, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
//   0x5a, 0x2e, 0x6c, 0x6f, 0x67, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
//   0x2e, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x61, 0x6e,
//   0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x2e,
//   0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x77, 0x65, 0x73,
//   0x74, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x62, 0x61, 0x74, 0x74, 0x65,
//   0x72, 0x79, 0x2e, 0x52, 0x61, 0x77, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72,
//   0x79, 0x47, 0x61, 0x75, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52,
//   0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x42, 0x2d, 0x0a, 0x16, 0x63,
//   0x6f, 0x6d, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x6f,
//   0x73, 0x2e, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x50, 0x01, 0x92,
//   0x03, 0x04, 0x20, 0x03, 0x10, 0x02, 0xd2, 0xef, 0x80, 0x90, 0x02, 0x06,
//   0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x62, 0x08, 0x65, 0x64, 0x69, 0x74,
//   0x69, 0x6f, 0x6e, 0x73, 0x70, 0xe8, 0x07, 0x0a, 0x55, 0x0a, 0x26, 0x73,
//   0x79, 0x6e, 0x74, 0x68, 0x65, 0x74, 0x69, 0x63, 0x2f, 0x61, 0x6e, 0x64,
//   0x72, 0x6f, 0x69, 0x64, 0x2f, 0x6f, 0x73, 0x2f, 0x73, 0x74, 0x61, 0x74,
//   0x73, 0x64, 0x2f, 0x61, 0x74, 0x6f, 0x6d, 0x2e, 0x70, 0x72, 0x6f, 0x74,
//   0x6f, 0x12, 0x11, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x6f,
//   0x73, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x64, 0x22, 0x10, 0x0a, 0x04,
//   0x41, 0x74, 0x6f, 0x6d, 0x2a, 0x08, 0x08, 0x01, 0x10, 0x80, 0x80, 0x80,
//   0x80, 0x02, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x32 
// };

// from test json amalg
{0x0a, 0xf0, 0x03, 0x0a, 0x60, 0x6c, 0x6f, 0x67, 0x73, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x2f, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x2f, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x2f, 0x77, 0x65, 0x73, 0x74, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2f, 0x61, 0x74, 0x6f, 0x6d, 0x73, 0x2f, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x2f, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x5f, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x61, 0x74, 0x6f, 0x6d, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x3c, 0x6c, 0x6f, 0x67, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x77, 0x65, 0x73, 0x74, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x22, 0x71, 0x0a, 0x1c, 0x52, 0x61, 0x77, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x47, 0x61, 0x75, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x12, 0x1f, 0x0a, 0x17, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6e, 0x61, 0x6e, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x03, 0x12, 0x15, 0x0a, 0x0d, 0x76, 0x6f, 0x6c, 0x74, 0x61, 0x67, 0x65, 0x5f, 0x76, 0x6f, 0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x02, 0x12, 0x19, 0x0a, 0x11, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6d, 0x69, 0x6c, 0x6c, 0x69, 0x61, 0x6d, 0x70, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x02, 0x3a, 0x9e, 0x01, 0x0a, 0x20, 0x72, 0x61, 0x77, 0x5f, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x5f, 0x67, 0x61, 0x75, 0x67, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x12, 0x17, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x6f, 0x73, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x64, 0x2e, 0x41, 0x74, 0x6f, 0x6d, 0x18, 0xbd, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x5a, 0x2e, 0x6c, 0x6f, 0x67, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x77, 0x65, 0x73, 0x74, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x2e, 0x52, 0x61, 0x77, 0x42, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x47, 0x61, 0x75, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x42, 0x2d, 0x0a, 0x16, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x6f, 0x73, 0x2e, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79, 0x50, 0x01, 0x92, 0x03, 0x04, 0x20, 0x03, 0x10, 0x02, 0xd2, 0xef, 0x80, 0x90, 0x02, 0x06, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x62, 0x08, 0x65, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x70, 0xe8, 0x07, 0x0a, 0x55, 0x0a, 0x26, 0x73, 0x79, 0x6e, 0x74, 0x68, 0x65, 0x74, 0x69, 0x63, 0x2f, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2f, 0x6f, 0x73, 0x2f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x64, 0x2f, 0x61, 0x74, 0x6f, 0x6d, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x11, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x6f, 0x73, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x64, 0x22, 0x10, 0x0a, 0x04, 0x41, 0x74, 0x6f, 0x6d, 0x2a, 0x08, 0x08, 0x01, 0x10, 0x80, 0x80, 0x80, 0x80, 0x02, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x32, 0x0a, 0x33, 0x0a, 0x0a, 0x61, 0x74, 0x6f, 0x6d, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x11, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e, 0x6f, 0x73, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x64, 0x22, 0x0a, 0x0a, 0x04, 0x41, 0x74, 0x6f, 0x6d, 0x2a, 0x02, 0x08, 0x01, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x32};


void RunBuiltinTest(StatsdModule* module) {
  std::cout << "\n--- RUNNING BUILT-IN TEST ---" << std::endl;

  protozero::HeapBuffered<protozero::Message> inner_msg_builder;

  // Field 2: voltage_volts (float)
  inner_msg_builder->AppendFixed(2, 3.85f);
  // Field 3: current_milliamps (float)
  inner_msg_builder->AppendFixed(3, 550.2f);
  std::vector<uint8_t> inner_msg_bytes = inner_msg_builder.SerializeAsArray();

  // 2. Build the outer 'Atom' message containing the extension.
  protozero::HeapBuffered<protozero::Message> atom_msg_builder;

  // Field 1085: our custom extension (RawBatteryGaugeStatsReported)
  atom_msg_builder->AppendBytes(1085, inner_msg_bytes.data(),
                                 inner_msg_bytes.size());
  std::vector<uint8_t> atom_msg_bytes = atom_msg_builder.SerializeAsArray();

  // 3. Call ParseAtom with the perfectly serialized byte array.
  module->ParseAtom(12345,
                    protozero::ConstBytes{atom_msg_bytes.data(),
                                          atom_msg_bytes.size()});
  std::cout << "--- BUILT-IN C++ TEST COMPLETE ---\n" << std::endl;
}

}  // namespace

using perfetto::protos::pbzero::StatsdAtom;
using perfetto::protos::pbzero::TracePacket;

StatsdModule::StatsdModule(TraceProcessorContext* context)
    : context_(context), args_parser_(*context_->descriptor_pool_) {
  RegisterForField(TracePacket::kStatsdAtomFieldNumber, context);
  
  // 1. Load the core statsd atoms descriptor set.
  context_->descriptor_pool_->AddFromFileDescriptorSet(kAtomsDescriptor.data(),
                                                       kAtomsDescriptor.size());

  // 2. Load the custom test atom descriptor. We check the status here.
  base::Status status = context_->descriptor_pool_->AddFromFileDescriptorSet(
      kTestAtomDescriptor, sizeof(kTestAtomDescriptor));

  

  // IMPORTANT: Check the status. If loading fails, this will fatal crash with
  // the specific error message instead of letting the program proceed with
  // corrupted state, which caused the "Illegal instruction" crash.
  if (!status.ok()) {
    PERFETTO_FATAL("Failed to load kTestAtomDescriptor: %s", status.c_message());
  }
  
  std::cout << "--- Loaded custom atom descriptor for testing. ---" << std::endl;

  // 3. Find the main Atom message descriptor index.
  if (auto i = context_->descriptor_pool_->FindDescriptorIdx(kAtomProtoName)) {
    descriptor_idx_ = *i;
  } else {
    PERFETTO_FATAL("Failed to find descriptor for %s", kAtomProtoName);
  }

  // 4. Run the test to ensure parsing works with the new descriptor.
  RunBuiltinTest(this);
}

StatsdModule::~StatsdModule() = default;

ModuleResult StatsdModule::TokenizePacket(
    const TracePacket::Decoder& decoder,
    TraceBlobView* /*packet*/,
    int64_t packet_timestamp,
    RefPtr<PacketSequenceStateGeneration> state,
    uint32_t field_id) {
  if (field_id != TracePacket::kStatsdAtomFieldNumber) {
    return ModuleResult::Ignored();
  }
  const auto& atoms_wrapper = StatsdAtom::Decoder(decoder.statsd_atom());
  auto it_timestamps = atoms_wrapper.timestamp_nanos();
  for (auto it = atoms_wrapper.atom(); it; ++it) {
    int64_t atom_timestamp;

    if (it_timestamps) {
      atom_timestamp = *it_timestamps++;
    } else {
      context_->storage->IncrementStats(stats::atom_timestamp_missing);
      atom_timestamp = packet_timestamp;
    }

    protozero::HeapBuffered<TracePacket> forged;

    forged->set_timestamp(static_cast<uint64_t>(atom_timestamp));

    auto* statsd = forged->set_statsd_atom();
    statsd->AppendBytes(StatsdAtom::kAtomFieldNumber, (*it).data, (*it).size);

    std::vector<uint8_t> vec = forged.SerializeAsArray();
    TraceBlob blob = TraceBlob::CopyFrom(vec.data(), vec.size());

    context_->sorter->PushTracePacket(
        atom_timestamp, state, TraceBlobView(std::move(blob)),
        context_->machine_id());
  }

  return ModuleResult::Handled();
}

void StatsdModule::ParseTracePacketData(const TracePacket::Decoder& decoder,
                                       int64_t ts,
                                       const TracePacketData&,
                                       uint32_t field_id) {
  if (field_id != TracePacket::kStatsdAtomFieldNumber) {
    return;
  }
  const auto& atoms_wrapper = StatsdAtom::Decoder(decoder.statsd_atom());
  auto it = atoms_wrapper.atom();
  PERFETTO_CHECK(it);
  ParseAtom(ts, *it++);
  PERFETTO_CHECK(!it);
}

void StatsdModule::ParseAtom(int64_t ts, protozero::ConstBytes nested_bytes) {
  protozero::ProtoDecoder nested_decoder(nested_bytes);
  protozero::Field field = nested_decoder.ReadField();
  uint32_t nested_field_id = 0;
  if (field.valid()) {
    nested_field_id = field.id();
  }

  std::cout << "\n--- Parsing Atom with Field ID: " << nested_field_id << " ---"
            << std::endl;

  StringId atom_name = GetAtomName(nested_field_id);
  context_->slice_tracker->Scoped(
      ts, InternTrackId(), kNullStringId, atom_name, 0,
      [&](ArgsTracker::BoundInserter* inserter) {
        ArgsParser delegate(ts, *inserter, *context_->storage);

        base::Status status = args_parser_.ParseMessage(
            nested_bytes, kAtomProtoName,
            nullptr /* parse all fields */, delegate);

        if (!status.ok()) {
          PERFETTO_LOG("Failed to parse atom field %u: %s", nested_field_id,
                       status.c_message());
          context_->storage->IncrementStats(stats::atom_unknown);
        }
      });
}

StringId StatsdModule::GetAtomName(uint32_t atom_field_id) {
  StringId* cached_name = atom_names_.Find(atom_field_id);
  if (cached_name == nullptr) {
    std::cout << "  [GetAtomName] Cache miss for ID " << atom_field_id
              << ". Looking up in descriptor." << std::endl;
    if (!descriptor_idx_) {
      context_->storage->IncrementStats(stats::atom_unknown);
      return context_->storage->InternString("Could not load atom descriptor");
    }

    const auto& descriptor =
        context_->descriptor_pool_->descriptors()[descriptor_idx_];
    StringId name_id;
    const auto& field_it = descriptor.fields().find(atom_field_id);
    if (field_it == descriptor.fields().end()) {
      base::StackString<255> name("atom_%u", atom_field_id);
      name_id = context_->storage->InternString(name.string_view());
      std::cout << "    > Lookup failed. Using generic name: " << name.c_str()
                << std::endl;
    } else {
      const FieldDescriptor& field = field_it->second;
      name_id = context_->storage->InternString(base::StringView(field.name()));
      std::cout << "    > Lookup successful! Found name: " << field.name()
                << std::endl;
    }
    atom_names_[atom_field_id] = name_id;
    return name_id;
  }
  return *cached_name;
}

TrackId StatsdModule::InternTrackId() {
  if (!track_id_) {
    static constexpr auto kBlueprint =
        tracks::SliceBlueprint("statsd_atoms", tracks::DimensionBlueprints(),
                               tracks::StaticNameBlueprint("Statsd Atoms"));
    track_id_ = context_->track_tracker->InternTrack(kBlueprint);
  }
  return *track_id_;
}

}  // namespace perfetto::trace_processor
