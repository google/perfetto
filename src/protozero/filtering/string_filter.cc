/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "src/protozero/filtering/string_filter.h"

#include <algorithm>
#include <cstdint>
#include <cstring>
#include <regex>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "perfetto/base/logging.h"
#include "perfetto/public/compiler.h"

namespace protozero {
namespace {

using Matches = std::match_results<char*>;

constexpr std::string_view kRedacted = "P60REDACTED";
constexpr char kRedactedDash = '-';

// Returns a pointer to the first character after the tgid pipe character in
// the atrace string given by [ptr, end). Returns null if no such character
// exists.
//
// Examples:
// E|1024 -> nullptr
// foobarbaz -> nullptr
// B|1024|x -> pointer to x
PERFETTO_ALWAYS_INLINE const char* FindAtracePayloadPtr(const char* ptr,
                                                        const char* end) {
  // Don't even bother checking any strings which are so short that they could
  // not contain a post-tgid section. This filters out strings like "E|" which
  // emitted by Bionic.
  //
  // Also filter out any other strings starting with "E" as they never contain
  // anything past the tgid: this removes >half of the strings for ~zero cost.
  static constexpr size_t kEarliestSecondPipeIndex = 2;
  const char* search_start = ptr + kEarliestSecondPipeIndex;
  if (PERFETTO_UNLIKELY(search_start >= end || *ptr == 'E')) {
    return nullptr;
  }

  // We skipped past the first '|' character by starting at the character at
  // index 2. Just find the next pipe character (i.e. the one after tgid) using
  // memchr.
  const char* pipe = static_cast<const char*>(
      memchr(search_start, '|', size_t(end - search_start)));
  return pipe ? pipe + 1 : nullptr;
}

PERFETTO_ALWAYS_INLINE bool StartsWith(const char* ptr,
                                       const char* end,
                                       const std::string& starts_with) {
  // Verify that the atrace string has enough characters to match against all
  // the characters in the "starts with" string.
  size_t len = starts_with.size();
  if (PERFETTO_UNLIKELY(ptr + len > end))
    return false;

  // Empty string matches everything.
  if (PERFETTO_UNLIKELY(len == 0))
    return true;

  // Quick rejection: check first character before expensive memcmp.
  // This is very effective since most strings don't match.
  if (PERFETTO_LIKELY(*ptr != *starts_with.data()))
    return false;

  // If first char matches, do full memcmp for remaining characters.
  return memcmp(ptr + 1, starts_with.data() + 1, len - 1) == 0;
}

void RedactMatches(const Matches& matches) {
  // Go through every group in the matches.
  for (size_t i = 1; i < matches.size(); ++i) {
    const auto& match = matches[i];
    PERFETTO_CHECK(match.second >= match.first);

    // Overwrite the match with characters from |kRedacted|. If match is
    // smaller, we will not use all of |kRedacted| but that's fine (i.e. we
    // will overwrite with a truncated |kRedacted|).
    auto match_len = static_cast<size_t>(match.second - match.first);
    size_t redacted_len = std::min(match_len, kRedacted.size());
    memcpy(match.first, kRedacted.data(), redacted_len);

    // Overwrite any characters after |kRedacted| with |kRedactedDash|.
    memset(match.first + redacted_len, kRedactedDash, match_len - redacted_len);
  }
}

// Checks if a semantic type matches the given rule's semantic type mask.
constexpr bool DoesRuleMatchSemanticType(
    const StringFilter::SemanticTypeMask& mask,
    uint32_t semantic_type) {
  // If beyond supported range (>= 128), apply rule (safe default).
  if (PERFETTO_UNLIKELY(semantic_type >= StringFilter::kSemanticTypeLimit)) {
    return true;
  }
  uint32_t word_index = semantic_type / 64;
  uint32_t bit_index = semantic_type % 64;
  return (mask[word_index] & (1ULL << bit_index)) != 0;
}

}  // namespace

void StringFilter::AddRule(Policy policy,
                           std::string_view pattern_str,
                           std::string atrace_payload_starts_with,
                           std::string name,
                           SemanticTypeMask semantic_type_mask) {
  Rule new_rule{
      policy,
      std::regex(pattern_str.begin(), pattern_str.end(),
                 std::regex::ECMAScript | std::regex_constants::optimize),
      std::move(atrace_payload_starts_with), std::move(name),
      semantic_type_mask};
  // If name is non-empty, look for existing rule with same name and replace.
  if (!new_rule.name.empty()) {
    for (Rule& existing : rules_) {
      if (existing.name == new_rule.name) {
        existing = std::move(new_rule);
        return;
      }
    }
  }
  rules_.push_back(std::move(new_rule));
}

bool StringFilter::MaybeFilterInternal(char* ptr,
                                       size_t len,
                                       uint32_t semantic_type) const {
  std::match_results<char*> matches;
  bool atrace_find_tried = false;
  const char* atrace_payload_ptr = nullptr;
  for (const Rule& rule : rules_) {
    if (!DoesRuleMatchSemanticType(rule.semantic_type_mask, semantic_type)) {
      continue;
    }
    switch (rule.policy) {
      case Policy::kMatchRedactGroups:
      case Policy::kMatchBreak:
        if (PERFETTO_UNLIKELY(
                std::regex_match(ptr, ptr + len, matches, rule.pattern))) {
          if (rule.policy == Policy::kMatchBreak) {
            return false;
          }
          RedactMatches(matches);
          return true;
        }
        break;
      case Policy::kAtraceMatchRedactGroups:
      case Policy::kAtraceMatchBreak:
        atrace_payload_ptr = atrace_find_tried
                                 ? atrace_payload_ptr
                                 : FindAtracePayloadPtr(ptr, ptr + len);
        atrace_find_tried = true;
        if (atrace_payload_ptr &&
            StartsWith(atrace_payload_ptr, ptr + len,
                       rule.atrace_payload_starts_with) &&
            std::regex_match(ptr, ptr + len, matches, rule.pattern)) {
          if (rule.policy == Policy::kAtraceMatchBreak) {
            return false;
          }
          RedactMatches(matches);
          return true;
        }
        break;
      case Policy::kAtraceRepeatedSearchRedactGroups:
        atrace_payload_ptr = atrace_find_tried
                                 ? atrace_payload_ptr
                                 : FindAtracePayloadPtr(ptr, ptr + len);
        atrace_find_tried = true;
        if (atrace_payload_ptr && StartsWith(atrace_payload_ptr, ptr + len,
                                             rule.atrace_payload_starts_with)) {
          auto beg = std::regex_iterator<char*>(ptr, ptr + len, rule.pattern);
          auto end = std::regex_iterator<char*>();
          bool has_any_matches = beg != end;
          for (auto it = std::move(beg); it != end; ++it) {
            RedactMatches(*it);
          }
          if (has_any_matches) {
            return true;
          }
        }
        break;
    }
  }
  return false;
}

}  // namespace protozero
