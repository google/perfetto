# Tracing with Out-of-Tree Protos

**Authors:** @primiano
**Status:** Draft
**PR:** N/A

## Problem

Going forward we are expecting more and more contributions to trace points
from code all over Android platform. Today when an Android developer wants to
define a custom TrackEvent proto (which is something that we highly encourage
to prevent stringification of args) they have to edit
[`android_track_event.proto`][android_track_event.proto] which involves a
GitHub PR.

This is highly inconvenient as it involves cross-repo changes and waiting for
autorollers.

Note that this problem is not just Android-specific and generally applies to
any other user of perfetto. This RFC focuses on Android to keep the discussion
concrete, but the solution generalizes.

Note also that this problem extends also to the lower-level DataSource SDK, not
just TrackEvent. We will focus on TE here, even though the solution can be
easily extended to DS.

## Goal

We want to allow developers to extend TrackEvent protos without requiring
multi-repo changes, to reduce the friction of using perfetto tracing to the
lowest possible.

## More context

When extending tracing protos, there are two parties involved that depend on
that proto:

### 1. The writer on the caller-side

E.g., .cc/java files in system_server, which emits the trace point.
This needs to depend on the proto to get the per-field constants used to invoke
SDK methods, e.g.

```java 
  PerfettoTrace.instant(PerfettoTrace.JOB_SCHEDULER_CATEGORY_V3, eventName)
    .beginProto()
    .beginNested(JOB_SCHEDULER_JOB_FIELD_ID);
```

That `JOB_SCHEDULER_JOB_FIELD_ID` is autogenerated from the .proto definitions.

This requires little discussion: somehow the .proto file must live or be reachable
in the Android tree. The only discussion is where the source-of-truth lives
and who has a copy.

### 2. Trace Processor on the consumer side

TraceProcessor must be aware of the .proto descriptors so it can convert those
nested protos into structured args. That in turn allows both queries and
visualization in the UI.

### Out Of Scope: TP custom parsing

The use-case of adding custom parsing C++ code to TraceProcessor to make some
advanced use of these protos is considered out of scope from this RFC. That one
requires far more than the descriptor and it is a niche use-case which, at
present, is not deemed to need a generalized solution.

The main challenge here is: how should TraceProcessor be aware of these
descriptors?

There are three possible solutions to this problem today, even before the
changes suggested by this RFC:

1. The protos are embedded in the TraceProcessor binary as they are available in
   the protos/ directory of upstream perfetto, on GitHub.

2. The protos get converted into a protobuf descriptor and that descriptor is
   made available in a Google-internal location. In turn those Google internal
   descriptors are available:
   1. In the Google-internal variants of trace_processor_shell
   2. In ui.perfetto.dev when opened from a Google-managed machine
   3. In internal Google dashboards (APC) which depend on the internal TP.
  
3. The descriptors can be embedded in the trace itself. See
   `TracePacket.extension_descriptor` and
   [`/docs/design-docs/extensions.md`](https://perfetto.dev/docs/design-docs/extensions)

## Proposed solution

### Source-of-truth protos live all over the Android tree

I'm envisioning breaking down the current [`android_track_event.proto`][android_track_event.proto]
into

`$ANDROID/frameworks/base/proto/src/tracing/android_frameworks_base.proto`
`$ANDROID/frameworks/av/proto/src/tracing/android_frameworks_av.proto`

and so on.

Each .proto should look like this:

```proto

message AndroidTrackEvent {
  // Usable range: [2001, 2999]
  extend TrackEvent {
    // The name of a binder service.
    optional string binder_service_name = 2001;
    // The name of a binder interface.
    optional string binder_interface_name = 2002;
    // The name of an apex.
    optional string apex_name = 2003;
    ...
  }
}
```

Inside our upstream (GitHub) track_event.proto we will need to reserve ranges
as follows:

```proto
// Range for Android's frameworks/base
extensions 2001 to 2999;

// Range for Android's frameworks/av
extensions 3000 to 3199;

```

The only thing that requires an upstream PR change is reserving the range for
every new repo. But that happens so rarely. We can live with that.

Likewise our project will be open to other companies or projects to register
their extension range.

Note that reserving a range is not even functionally mandatory. The only reason
why we encourage that is to prevent two independent projects from clashing on the
same IDs (unlikely across other companies, very likely across different Android
git projects)

### Generating a fused descriptor

At the build-level, in Android, the following needs to happen: an Android.bp
rule in a central place (could be //external/perfetto itself, TBD) must be aware
of all the targets that define tracing protos (e.g.
`frameworks_base_tracing_protos`, `frameworks_av_tracing_protos`).

A gen rule has to take all these protos, generate a protobuf descriptor and make
sure this descriptor ends up in the system image, e.g. under
`/system/usr/share/tracing_protos.descriptor.gz`

Realistically we will need something similar for /vendor.

[android_track_event.proto]: https://github.com/google/perfetto/blob/d18b5e4e8ab932c663c3c6b6410d712ba09eb948/protos/perfetto/trace/android/android_track_event.proto#L4


### Traced dumps the protos in the trace

For Android builds (both standalone and in-tree), we can teach traced to simply
dump `/system/usr/share/tracing_protos.descriptor.gz` into the trace itself
so every trace collected from Android has all the up-to-date descriptors which
allow UI, APC, and any trace_processor version to JustWork.

This would happen in `TracingServiceImpl::ReadBuffers()` next to the various
`MaybeEmit...` so it is not affected by any buffering issue.

This opens a little problem: as these protos keep growing, there is a fixed
overhead (in terms of trace size) added to every Android trace. Let's pull some
numbers:

Even if we assume that the Android tracing protos grow as much as
[atoms.proto](go/atoms.proto), a monster-proto of 26K lines, the whole
atoms.descriptor is still 326 KB after gzip compression (252 KB after xz/lzma
compression). Realistically we have some years until this becomes a problem.

I can envision two solutions to mitigate this problem

### Dump only the delta from last AOSP push (preferred)

Every time Android does AOSP drops we can copy back the various
frameworks_xxx_protos into GitHub. Then we need to make the dumping code slightly
more sophisticated and only dump the protos that changed from the last AOSP push.

### Dump only the protos used

Today TracingServiceImpl already iterates through each packet at readback-time
for PacketStreamValidator. We could teach PacketStreamValidator to remember the
field IDs of the packets used (it will need to recurse one level into
TrackEvent) and only emit the descriptors for the packets used.
Realistically I don't think it's worth going into this complexity.

Note that we also have the ability of stripping out unwanted descriptors via the
privacy filter bytecode.

## Alternatives considered

### Use the Google-internal protos

Rather than dumping the descriptors into the trace, we could rely on the fact
that the various Android protos could be periodically merged into google3 and
become part of the Google-internal descriptors that the UI, APC and the internal
release of trace_processor_shell uses.

**PRO:** This avoids the increase in the trace size.

**CONs:** This doesn't JustWork(TM). There are a number of edge cases that are
not captured by this solution and would cause too many surprise factors:

1. Local development cycles: I am an Android developer, add a frameworks/base
   proto in my local tree and want to see how a trace looks like.
2. I am an Android engineer and I am opening a trace on a mac laptop using the
   upstream trace_processor_shell. People can't get easily ahold of a
   google-internal trace_processor_shell on mac laptops (this would require our
   team maintaining a google-internal mac build of tp_shell)
3. Lab test scenarios that are not using the google-internal TP build.
4. OEMs/Android partners creating their own proto extensions.
5. OEMs/Android partners opening Android traces from recent versions of Android (This could be solved with the RFC0006 but add yet another problem to solve)
